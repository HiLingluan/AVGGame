//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

pub struct LoadError {

}

impl std::fmt::Debug for LoadError {
    fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> { Ok(()) }
}

#[allow(dead_code)]
pub struct Vector2 {
    pub x:f32,
    pub y:f32,
}

impl Vector2 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector2, LoadError> {
        Ok(Vector2{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}

#[allow(dead_code)]
pub struct Vector3 {
    pub x:f32,
    pub y:f32,
    pub z:f32,
}

impl Vector3 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector3, LoadError> {
        Ok(Vector3{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            z: match __js["z"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}

#[allow(dead_code)]
pub struct Vector4 {
    pub x:f32,
    pub y:f32,
    pub z:f32,
    pub w:f32,
}


impl Vector4 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector4, LoadError> {
        Ok(Vector4{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            z: match __js["z"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            w: match __js["w"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiEExecutor {
    CLIENT = 0,
    SERVER = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiEKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS = 8,
    ENUM = 9,
    OBJECT = 10,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiEFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiEFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum AiEOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum CommonEBoolOperator {
    AND = 0,
    OR = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ErrorEOperation {
    /**
     * 登出
     */
    LOGOUT = 0,
    /**
     * 重启
     */
    RESTART = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ErrorEErrorCode {
    OK = 0,
    SERVER_NOT_EXISTS = 1,
    HAS_BIND_SERVER = 2,
    AUTH_FAIL = 3,
    NOT_BIND_SERVER = 4,
    SERVER_ACCESS_FAIL = 5,
    EXAMPLE_FLASH = 6,
    EXAMPLE_MSGBOX = 7,
    EXAMPLE_DLG_OK = 8,
    EXAMPLE_DLG_OK_CANCEL = 9,
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    ROLE_CREATE_NAME_EMPTY = 101,
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    ROLE_CREATE_INVALID_PROFESSION = 104,
    ROLE_CREATE_INVALID_GENDER = 105,
    ROLE_NOT_OWNED_BY_USER = 106,
    ROLE_LEVEL_NOT_ARRIVE = 107,
    PARAM_ILLEGAL = 200,
    TEMP_BAG_NOT_EMPTY = 201,
    ITEM_CAN_NOT_USE = 202,
    CURRENCY_NOT_ENOUGH = 203,
    BAG_IS_FULL = 204,
    ITEM_NOT_ENOUGH = 205,
    ITEM_IN_BAG = 206,
    GENDER_NOT_MATCH = 300,
    LEVEL_TOO_LOW = 301,
    LEVEL_TOO_HIGH = 302,
    EXCEED_LIMIT = 303,
    OVER_TIME = 304,
    SERVER_ERROR = 305,
    SKILL_NOT_IN_LIST = 400,
    SKILL_NOT_COOLDOWN = 401,
    SKILL_TARGET_NOT_EXIST = 402,
    SKILL_ANOTHER_CASTING = 403,
    SKILL_OUT_OF_DISTANCE = 404,
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    SKILL_INVALID_DIRECTION = 406,
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    SKILL_ENERGY_NOT_ENOUGH = 408,
    DIALOG_NODE_NOT_CHOOSEN = 500,
    DIALOG_NOT_FINISH = 501,
    DIALOG_HAS_FINISH = 502,
    QUEST_STAGE_NOT_FINISHED = 503,
    QUEST_NOT_DOING = 504,
    QUEST_STAGE_NOT_DOING = 505,
    QUEST_HAS_ACCEPTED = 506,
    MAP_OBJECT_NOT_EXIST = 600,
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    HAS_NOT_EQUIP = 602,
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    NOT_AVAILABLE_SUIT_ID = 604,
    NO_INTERACTION_COMPONENT = 605,
    HAS_INTERACTED = 606,
    VIALITY_NOT_ENOUGH = 607,
    PLAYER_SESSION_NOT_EXIST = 608,
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    MAP_NOT_EXIST = 610,
    MAIL_TYPE_ERROR = 700,
    MAIL_NOT_EXITST = 701,
    MAIL_HAVE_DELETED = 702,
    MAIL_AWARD_HAVE_RECEIVED = 703,
    MAIL_OPERATE_TYPE_ERROR = 704,
    MAIL_CONDITION_NOT_MEET = 705,
    MAIL_STATE_ERROR = 706,
    MAIL_NO_AWARD = 707,
    MAIL_BOX_IS_FULL = 708,
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    NOT_WEAR_CLOTHES = 801,
    NOT_WEAR_SUIT = 802,
    SUIT_NOT_UNLOCK = 900,
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    SUIT_STATE_ERROR = 902,
    SUIT_COMPONENT_STATE_ERROR = 903,
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    STORE_NOT_ENABLED = 1000,
    SHELF_NOT_ENABLED = 1001,
    GOODS_NOT_ENABLED = 1002,
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    RETRY = 1100,
    NOT_COOLDOWN = 1101,
    SELFIE_UNLOCK = 1200,
    SELFIE_ALREADY_UNLOCK = 1201,
    SELFIE_LACK_STARTS = 1202,
    SELFIE_HAD_REWARD = 1203,
}



/**
 * 道具品质
 */
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEItemQuality {
    /**
     * 白
     */
    WHITE = 0,
    /**
     * 绿
     */
    GREEN = 1,
    /**
     * 蓝
     */
    BLUE = 2,
    /**
     * 紫
     */
    PURPLE = 3,
    /**
     * 金
     */
    GOLDEN = 4,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemECurrencyType {
    /**
     * 钻石
     */
    DIAMOND = 1,
    /**
     * 金币
     */
    GOLD = 2,
    /**
     * 银币
     */
    SILVER = 3,
    /**
     * 经验
     */
    EXP = 4,
    /**
     * 能量点
     */
    POWER_POINT = 5,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEMajorType {
    /**
     * 货币
     */
    CURRENCY = 1,
    /**
     * 服装
     */
    CLOTH = 2,
    /**
     * 任务
     */
    QUEST = 3,
    /**
     * 消耗品
     */
    CONSUMABLES = 4,
    /**
     * 宝箱
     */
    TREASURE_BOX = 5,
    /**
     * 成就和称谓
     */
    ACHIEVEMENT_AND_TITLE = 6,
    /**
     * 头像框
     */
    HEAD_FRAME = 7,
    /**
     * 语音
     */
    VOICE = 8,
    /**
     * 动作
     */
    ACTION = 9,
    /**
     * 扩容道具
     */
    EXPANSION = 10,
    /**
     * 制作材料
     */
    MATERIAL = 11,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEMinorType {
    /**
     * 钻石
     */
    DIAMOND = 101,
    /**
     * 金币
     */
    GOLD = 102,
    /**
     * 银币
     */
    SILVER = 103,
    /**
     * 经验
     */
    EXP = 104,
    /**
     * 能量点
     */
    POWER_POINT = 105,
    /**
     * 发型
     */
    HAIR_STYLE = 210,
    /**
     * 外套
     */
    COAT = 220,
    /**
     * 上衣
     */
    UPPER_JACKET = 230,
    /**
     * 裤子
     */
    TROUSERS = 241,
    /**
     * 裙子
     */
    SKIRT = 242,
    /**
     * 袜子
     */
    SOCKS = 250,
    /**
     * 鞋子
     */
    SHOES = 260,
    /**
     * 发饰
     */
    HAIR_ACCESSORY = 271,
    /**
     * 帽子
     */
    HAT = 272,
    /**
     * 耳饰
     */
    EARRING = 273,
    /**
     * 颈饰
     */
    NECKLACE = 274,
    /**
     * 腕饰
     */
    BRACELET = 275,
    /**
     * 发箍
     */
    HAIR_CLASP = 276,
    /**
     * 手套
     */
    GLOVE = 277,
    /**
     * 手持物
     */
    HANDHELD_OBJECT = 278,
    /**
     * 特殊
     */
    SPECIAL = 279,
    /**
     * 底妆
     */
    BASE_COSMETIC = 281,
    /**
     * 眉妆
     */
    EYEBROW_COSMETIC = 282,
    /**
     * 睫毛
     */
    EYELASH = 283,
    /**
     * 美瞳
     */
    COSMETIC_CONTACT_LENSES = 284,
    /**
     * 唇妆
     */
    LIP_COSMETIC = 285,
    /**
     * 肤色
     */
    SKIN_COLOR = 286,
    /**
     * 连衣裙
     */
    ONE_PIECE_DRESS = 290,
    /**
     * 换装场景
     */
    SWITCH_CLOTHES_SCENE = 291,
    /**
     * 任务道具
     */
    QUEST = 301,
    /**
     * 投掷物
     */
    CAST = 401,
    /**
     * 刀剑
     */
    SWORD = 421,
    /**
     * 弓箭
     */
    BOW_ARROW = 422,
    /**
     * 法杖
     */
    WANDS = 423,
    /**
     * 特殊工具
     */
    SPECIAL_TOOL = 424,
    /**
     * 食物
     */
    FOOD = 403,
    /**
     * 宝箱
     */
    TREASURE_BOX = 501,
    /**
     * 钥匙
     */
    KEY = 502,
    /**
     * 多选一宝箱
     */
    MULTI_CHOOSE_TREASURE_BOX = 503,
    /**
     * 成就相关
     */
    ACHIEVEMENT = 601,
    /**
     * 称谓相关
     */
    TITLE = 602,
    /**
     * 头像框
     */
    AVATAR_FRAME = 701,
    /**
     * 语音
     */
    VOICE = 801,
    /**
     * 特殊待机动作
     */
    IDLE_POSE = 901,
    /**
     * 拍照动作
     */
    PHOTO_POSE = 902,
    /**
     * 背包
     */
    BAG = 1001,
    /**
     * 好友数量
     */
    FRIEND_CAPACITY = 1002,
    /**
     * 制作材料
     */
    CONSTRUCTION_MATERIAL = 1101,
    /**
     * 设计图纸
     */
    DESIGN_DRAWING = 1102,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEClothersStarQualityType {
    /**
     * 一星
     */
    ONE = 1,
    /**
     * 二星
     */
    TWO = 2,
    /**
     * 三星
     */
    THREE = 3,
    /**
     * 四星
     */
    FOUR = 4,
    /**
     * 五星
     */
    FIVE = 5,
    /**
     * 六星
     */
    SIX = 6,
    /**
     * 七星
     */
    SEVEN = 7,
    /**
     * 八星
     */
    EIGHT = 8,
    /**
     * 九星
     */
    NINE = 9,
    /**
     * 十星
     */
    TEN = 10,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEClothersTag {
    /**
     * 防晒
     */
    FANG_SHAI = 1,
    /**
     * 舞者
     */
    WU_ZHE = 2,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEUseType {
    /**
     * 手动
     */
    MANUAL = 0,
    /**
     * 自动
     */
    AUTO = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEClothesHidePartType {
    /**
     * 胸部
     */
    CHEST = 0,
    /**
     * 手
     */
    HEAD = 1,
    /**
     * 脊柱上
     */
    SPINE_UPPER = 2,
    /**
     * 脊柱下
     */
    SPINE_LOWER = 3,
    /**
     * 臀部
     */
    HIP = 4,
    /**
     * 腿上
     */
    LEG_UPPER = 5,
    /**
     * 腿中
     */
    LEG_MIDDLE = 6,
    /**
     * 腿下
     */
    LEG_LOWER = 7,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEClothesPropertyType {
    /**
     * 简约
     */
    JIAN_YUE = 1,
    /**
     * 华丽
     */
    HUA_LI = 2,
    /**
     * 可爱
     */
    KE_AI = 3,
    /**
     * 成熟
     */
    CHENG_SHU = 4,
    /**
     * 活泼
     */
    HUO_PO = 5,
    /**
     * 优雅
     */
    YOU_YA = 6,
    /**
     * 清纯
     */
    QING_CHUN = 7,
    /**
     * 性感
     */
    XING_GAN = 8,
    /**
     * 清凉
     */
    QING_LIANG = 9,
    /**
     * 保暖
     */
    BAO_NUAN = 10,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum ItemEItemFunctionType {
    /**
     * 更换手持物
     */
    REPLACE_HANDHELD = 0,
    /**
     * 使用设计图纸
     */
    USE_DESIGN_DRAWING = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum LimitENamespace {
    ITEM_DAILY_OBTAIN = 1,
    TREASURE_DAILY_USE = 2,
    STORE_GOODS_LIMIT_BUY = 3,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum MailEMailType {
    /**
     * 全局邮件
     */
    GLOBAL = 0,
    /**
     * 系统邮件
     */
    SYSTEM = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum RoleEGenderType {
    /**
     * 男
     */
    MALE = 1,
    /**
     * 女
     */
    FEMALE = 2,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum RoleEProfession {
    TEST_PROFESSION = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestDemoEnum {
    NONE = 0,
    /**
     * aa
     */
    A = 1,
    /**
     * bb
     */
    B = 2,
    /**
     * cc
     */
    C = 4,
    /**
     * dd
     */
    D = 5,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestDemoFlag {
    A = 1,
    B = 2,
    D = 3,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestETestUeType {
    /**
     * 白
     */
    WHITE = 0,
    BLACK = 1,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestETestEmptyEnum {
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestAudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestETestQuality {
    /**
     * 最高品质
     */
    A = 1,
    /**
     * 黑色的
     */
    B = 2,
    /**
     * 蓝色的
     */
    C = 3,
    /**
     * 最差品质
     */
    D = 4,
}



#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum TestAccessFlag {
    WRITE = 1,
    READ = 2,
    TRUNCATE = 4,
    NEW = 8,
    READ_WRITE = 3,
}



#[allow(non_camel_case_types)]
pub struct AiTbBlackboard {
    data_list: Vec<std::rc::Rc<AiBlackboard>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<AiBlackboard>>,
}

impl AiTbBlackboard{
    pub fn new(__js: &json::JsonValue) -> Result<AiTbBlackboard, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = AiTbBlackboard {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match AiBlackboard::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.name.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&AiTbBlackboard) -> &std::collections::HashMap<String, std::rc::Rc<AiBlackboard>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&AiTbBlackboard) -> &Vec<std::rc::Rc<AiBlackboard>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&AiTbBlackboard, key: &String) -> std::option::Option<&std::rc::Rc<AiBlackboard>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct AiBlackboard {
pub name: String,
pub desc: String,
pub parent_name: String,
pub keys: Vec<AiBlackboardKey>,
}

impl AiBlackboard {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiBlackboard, LoadError> {
        let __b = AiBlackboard {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parent_name: match __js["parent_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            keys: { if !__js["keys"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["keys"].members() { __list__.push(AiBlackboardKey::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiBlackboardKey {
pub name: String,
pub desc: String,
pub is_static: bool,
pub r#type: i32,
pub type_class_name: String,
}

impl AiBlackboardKey {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiBlackboardKey, LoadError> {
        let __b = AiBlackboardKey {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            type_class_name: match __js["type_class_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct AiTbBehaviorTree {
    data_list: Vec<std::rc::Rc<AiBehaviorTree>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<AiBehaviorTree>>,
}

impl AiTbBehaviorTree{
    pub fn new(__js: &json::JsonValue) -> Result<AiTbBehaviorTree, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = AiTbBehaviorTree {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match AiBehaviorTree::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&AiTbBehaviorTree) -> &std::collections::HashMap<i32, std::rc::Rc<AiBehaviorTree>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&AiTbBehaviorTree) -> &Vec<std::rc::Rc<AiBehaviorTree>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&AiTbBehaviorTree, key: &i32) -> std::option::Option<&std::rc::Rc<AiBehaviorTree>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct AiBehaviorTree {
pub id: i32,
pub name: String,
pub desc: String,
pub blackboard_id: String,
pub root: AiComposeNode,
}

impl AiBehaviorTree {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiBehaviorTree, LoadError> {
        let __b = AiBehaviorTree {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            blackboard_id: match __js["blackboard_id"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            root: AiComposeNode::new(&__js["root"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiNode {
  UeSetDefaultFocus(Box<AiUeSetDefaultFocus>),
  ExecuteTimeStatistic(Box<AiExecuteTimeStatistic>),
  ChooseTarget(Box<AiChooseTarget>),
  KeepFaceTarget(Box<AiKeepFaceTarget>),
  GetOwnerPlayer(Box<AiGetOwnerPlayer>),
  UpdateDailyBehaviorProps(Box<AiUpdateDailyBehaviorProps>),
  UeLoop(Box<AiUeLoop>),
  UeCooldown(Box<AiUeCooldown>),
  UeTimeLimit(Box<AiUeTimeLimit>),
  UeBlackboard(Box<AiUeBlackboard>),
  UeForceSuccess(Box<AiUeForceSuccess>),
  IsAtLocation(Box<AiIsAtLocation>),
  DistanceLessThan(Box<AiDistanceLessThan>),
  Sequence(Box<AiSequence>),
  Selector(Box<AiSelector>),
  SimpleParallel(Box<AiSimpleParallel>),
  UeWait(Box<AiUeWait>),
  UeWaitBlackboardTime(Box<AiUeWaitBlackboardTime>),
  MoveToTarget(Box<AiMoveToTarget>),
  ChooseSkill(Box<AiChooseSkill>),
  MoveToRandomLocation(Box<AiMoveToRandomLocation>),
  MoveToLocation(Box<AiMoveToLocation>),
  DebugPrint(Box<AiDebugPrint>),
}

impl AiNode {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiNode, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeSetDefaultFocus" => AiNode::UeSetDefaultFocus(Box::new(AiUeSetDefaultFocus::new(&__js)?)),
                "ExecuteTimeStatistic" => AiNode::ExecuteTimeStatistic(Box::new(AiExecuteTimeStatistic::new(&__js)?)),
                "ChooseTarget" => AiNode::ChooseTarget(Box::new(AiChooseTarget::new(&__js)?)),
                "KeepFaceTarget" => AiNode::KeepFaceTarget(Box::new(AiKeepFaceTarget::new(&__js)?)),
                "GetOwnerPlayer" => AiNode::GetOwnerPlayer(Box::new(AiGetOwnerPlayer::new(&__js)?)),
                "UpdateDailyBehaviorProps" => AiNode::UpdateDailyBehaviorProps(Box::new(AiUpdateDailyBehaviorProps::new(&__js)?)),
                "UeLoop" => AiNode::UeLoop(Box::new(AiUeLoop::new(&__js)?)),
                "UeCooldown" => AiNode::UeCooldown(Box::new(AiUeCooldown::new(&__js)?)),
                "UeTimeLimit" => AiNode::UeTimeLimit(Box::new(AiUeTimeLimit::new(&__js)?)),
                "UeBlackboard" => AiNode::UeBlackboard(Box::new(AiUeBlackboard::new(&__js)?)),
                "UeForceSuccess" => AiNode::UeForceSuccess(Box::new(AiUeForceSuccess::new(&__js)?)),
                "IsAtLocation" => AiNode::IsAtLocation(Box::new(AiIsAtLocation::new(&__js)?)),
                "DistanceLessThan" => AiNode::DistanceLessThan(Box::new(AiDistanceLessThan::new(&__js)?)),
                "Sequence" => AiNode::Sequence(Box::new(AiSequence::new(&__js)?)),
                "Selector" => AiNode::Selector(Box::new(AiSelector::new(&__js)?)),
                "SimpleParallel" => AiNode::SimpleParallel(Box::new(AiSimpleParallel::new(&__js)?)),
                "UeWait" => AiNode::UeWait(Box::new(AiUeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => AiNode::UeWaitBlackboardTime(Box::new(AiUeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => AiNode::MoveToTarget(Box::new(AiMoveToTarget::new(&__js)?)),
                "ChooseSkill" => AiNode::ChooseSkill(Box::new(AiChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => AiNode::MoveToRandomLocation(Box::new(AiMoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => AiNode::MoveToLocation(Box::new(AiMoveToLocation::new(&__js)?)),
                "DebugPrint" => AiNode::DebugPrint(Box::new(AiDebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiService {
  UeSetDefaultFocus(Box<AiUeSetDefaultFocus>),
  ExecuteTimeStatistic(Box<AiExecuteTimeStatistic>),
  ChooseTarget(Box<AiChooseTarget>),
  KeepFaceTarget(Box<AiKeepFaceTarget>),
  GetOwnerPlayer(Box<AiGetOwnerPlayer>),
  UpdateDailyBehaviorProps(Box<AiUpdateDailyBehaviorProps>),
}

impl AiService {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiService, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeSetDefaultFocus" => AiService::UeSetDefaultFocus(Box::new(AiUeSetDefaultFocus::new(&__js)?)),
                "ExecuteTimeStatistic" => AiService::ExecuteTimeStatistic(Box::new(AiExecuteTimeStatistic::new(&__js)?)),
                "ChooseTarget" => AiService::ChooseTarget(Box::new(AiChooseTarget::new(&__js)?)),
                "KeepFaceTarget" => AiService::KeepFaceTarget(Box::new(AiKeepFaceTarget::new(&__js)?)),
                "GetOwnerPlayer" => AiService::GetOwnerPlayer(Box::new(AiGetOwnerPlayer::new(&__js)?)),
                "UpdateDailyBehaviorProps" => AiService::UpdateDailyBehaviorProps(Box::new(AiUpdateDailyBehaviorProps::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeSetDefaultFocus {
pub id: i32,
pub node_name: String,
pub keyboard_key: String,
}

impl AiUeSetDefaultFocus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeSetDefaultFocus, LoadError> {
        let __b = AiUeSetDefaultFocus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            keyboard_key: match __js["keyboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiExecuteTimeStatistic {
pub id: i32,
pub node_name: String,
}

impl AiExecuteTimeStatistic {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiExecuteTimeStatistic, LoadError> {
        let __b = AiExecuteTimeStatistic {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiChooseTarget {
pub id: i32,
pub node_name: String,
pub result_target_key: String,
}

impl AiChooseTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiChooseTarget, LoadError> {
        let __b = AiChooseTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            result_target_key: match __js["result_target_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiKeepFaceTarget {
pub id: i32,
pub node_name: String,
pub target_actor_key: String,
}

impl AiKeepFaceTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiKeepFaceTarget, LoadError> {
        let __b = AiKeepFaceTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiGetOwnerPlayer {
pub id: i32,
pub node_name: String,
pub player_actor_key: String,
}

impl AiGetOwnerPlayer {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiGetOwnerPlayer, LoadError> {
        let __b = AiGetOwnerPlayer {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            player_actor_key: match __js["player_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUpdateDailyBehaviorProps {
pub id: i32,
pub node_name: String,
pub satiety_key: String,
pub energy_key: String,
pub mood_key: String,
pub satiety_lower_threshold_key: String,
pub satiety_upper_threshold_key: String,
pub energy_lower_threshold_key: String,
pub energy_upper_threshold_key: String,
pub mood_lower_threshold_key: String,
pub mood_upper_threshold_key: String,
}

impl AiUpdateDailyBehaviorProps {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUpdateDailyBehaviorProps, LoadError> {
        let __b = AiUpdateDailyBehaviorProps {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_key: match __js["satiety_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_key: match __js["energy_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_key: match __js["mood_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_lower_threshold_key: match __js["satiety_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_upper_threshold_key: match __js["satiety_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_lower_threshold_key: match __js["energy_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_upper_threshold_key: match __js["energy_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_lower_threshold_key: match __js["mood_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_upper_threshold_key: match __js["mood_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiDecorator {
  UeLoop(Box<AiUeLoop>),
  UeCooldown(Box<AiUeCooldown>),
  UeTimeLimit(Box<AiUeTimeLimit>),
  UeBlackboard(Box<AiUeBlackboard>),
  UeForceSuccess(Box<AiUeForceSuccess>),
  IsAtLocation(Box<AiIsAtLocation>),
  DistanceLessThan(Box<AiDistanceLessThan>),
}

impl AiDecorator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiDecorator, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeLoop" => AiDecorator::UeLoop(Box::new(AiUeLoop::new(&__js)?)),
                "UeCooldown" => AiDecorator::UeCooldown(Box::new(AiUeCooldown::new(&__js)?)),
                "UeTimeLimit" => AiDecorator::UeTimeLimit(Box::new(AiUeTimeLimit::new(&__js)?)),
                "UeBlackboard" => AiDecorator::UeBlackboard(Box::new(AiUeBlackboard::new(&__js)?)),
                "UeForceSuccess" => AiDecorator::UeForceSuccess(Box::new(AiUeForceSuccess::new(&__js)?)),
                "IsAtLocation" => AiDecorator::IsAtLocation(Box::new(AiIsAtLocation::new(&__js)?)),
                "DistanceLessThan" => AiDecorator::DistanceLessThan(Box::new(AiDistanceLessThan::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeLoop {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub num_loops: i32,
pub infinite_loop: bool,
pub infinite_loop_timeout_time: f32,
}

impl AiUeLoop {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeLoop, LoadError> {
        let __b = AiUeLoop {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num_loops: match __js["num_loops"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            infinite_loop: match __js["infinite_loop"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            infinite_loop_timeout_time: match __js["infinite_loop_timeout_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeCooldown {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub cooldown_time: f32,
}

impl AiUeCooldown {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeCooldown, LoadError> {
        let __b = AiUeCooldown {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cooldown_time: match __js["cooldown_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeTimeLimit {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub limit_time: f32,
}

impl AiUeTimeLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeTimeLimit, LoadError> {
        let __b = AiUeTimeLimit {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            limit_time: match __js["limit_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeBlackboard {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub notify_observer: i32,
pub blackboard_key: String,
pub key_query: AiKeyQueryOperator,
}

impl AiUeBlackboard {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeBlackboard, LoadError> {
        let __b = AiUeBlackboard {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            notify_observer: match __js["notify_observer"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            blackboard_key: match __js["blackboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            key_query: AiKeyQueryOperator::new(&__js["key_query"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiKeyQueryOperator {
  IsSet(Box<AiIsSet>),
  IsNotSet(Box<AiIsNotSet>),
  BinaryOperator(Box<AiBinaryOperator>),
}

impl AiKeyQueryOperator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiKeyQueryOperator, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "IsSet" => AiKeyQueryOperator::IsSet(Box::new(AiIsSet::new(&__js)?)),
                "IsNotSet" => AiKeyQueryOperator::IsNotSet(Box::new(AiIsNotSet::new(&__js)?)),
                "BinaryOperator" => AiKeyQueryOperator::BinaryOperator(Box::new(AiBinaryOperator::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiIsSet {
}

impl AiIsSet {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiIsSet, LoadError> {
        let __b = AiIsSet {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiIsNotSet {
}

impl AiIsNotSet {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiIsNotSet, LoadError> {
        let __b = AiIsNotSet {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiBinaryOperator {
pub oper: i32,
pub data: AiKeyData,
}

impl AiBinaryOperator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiBinaryOperator, LoadError> {
        let __b = AiBinaryOperator {
            oper: match __js["oper"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            data: AiKeyData::new(&__js["data"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiKeyData {
  FloatKeyData(Box<AiFloatKeyData>),
  IntKeyData(Box<AiIntKeyData>),
  StringKeyData(Box<AiStringKeyData>),
  BlackboardKeyData(Box<AiBlackboardKeyData>),
}

impl AiKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiKeyData, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "FloatKeyData" => AiKeyData::FloatKeyData(Box::new(AiFloatKeyData::new(&__js)?)),
                "IntKeyData" => AiKeyData::IntKeyData(Box::new(AiIntKeyData::new(&__js)?)),
                "StringKeyData" => AiKeyData::StringKeyData(Box::new(AiStringKeyData::new(&__js)?)),
                "BlackboardKeyData" => AiKeyData::BlackboardKeyData(Box::new(AiBlackboardKeyData::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiFloatKeyData {
pub value: f32,
}

impl AiFloatKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiFloatKeyData, LoadError> {
        let __b = AiFloatKeyData {
            value: match __js["value"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiIntKeyData {
pub value: i32,
}

impl AiIntKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiIntKeyData, LoadError> {
        let __b = AiIntKeyData {
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiStringKeyData {
pub value: String,
}

impl AiStringKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiStringKeyData, LoadError> {
        let __b = AiStringKeyData {
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiBlackboardKeyData {
pub value: String,
}

impl AiBlackboardKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiBlackboardKeyData, LoadError> {
        let __b = AiBlackboardKeyData {
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeForceSuccess {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
}

impl AiUeForceSuccess {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeForceSuccess, LoadError> {
        let __b = AiUeForceSuccess {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiIsAtLocation {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub acceptable_radius: f32,
pub keyboard_key: String,
pub inverse_condition: bool,
}

impl AiIsAtLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiIsAtLocation, LoadError> {
        let __b = AiIsAtLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            keyboard_key: match __js["keyboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            inverse_condition: match __js["inverse_condition"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiDistanceLessThan {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub actor1_key: String,
pub actor2_key: String,
pub distance: f32,
pub reverse_result: bool,
}

impl AiDistanceLessThan {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiDistanceLessThan, LoadError> {
        let __b = AiDistanceLessThan {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            actor1_key: match __js["actor1_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            actor2_key: match __js["actor2_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            distance: match __js["distance"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            reverse_result: match __js["reverse_result"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiFlowNode {
  Sequence(Box<AiSequence>),
  Selector(Box<AiSelector>),
  SimpleParallel(Box<AiSimpleParallel>),
  UeWait(Box<AiUeWait>),
  UeWaitBlackboardTime(Box<AiUeWaitBlackboardTime>),
  MoveToTarget(Box<AiMoveToTarget>),
  ChooseSkill(Box<AiChooseSkill>),
  MoveToRandomLocation(Box<AiMoveToRandomLocation>),
  MoveToLocation(Box<AiMoveToLocation>),
  DebugPrint(Box<AiDebugPrint>),
}

impl AiFlowNode {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiFlowNode, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Sequence" => AiFlowNode::Sequence(Box::new(AiSequence::new(&__js)?)),
                "Selector" => AiFlowNode::Selector(Box::new(AiSelector::new(&__js)?)),
                "SimpleParallel" => AiFlowNode::SimpleParallel(Box::new(AiSimpleParallel::new(&__js)?)),
                "UeWait" => AiFlowNode::UeWait(Box::new(AiUeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => AiFlowNode::UeWaitBlackboardTime(Box::new(AiUeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => AiFlowNode::MoveToTarget(Box::new(AiMoveToTarget::new(&__js)?)),
                "ChooseSkill" => AiFlowNode::ChooseSkill(Box::new(AiChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => AiFlowNode::MoveToRandomLocation(Box::new(AiMoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => AiFlowNode::MoveToLocation(Box::new(AiMoveToLocation::new(&__js)?)),
                "DebugPrint" => AiFlowNode::DebugPrint(Box::new(AiDebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiComposeNode {
  Sequence(Box<AiSequence>),
  Selector(Box<AiSelector>),
  SimpleParallel(Box<AiSimpleParallel>),
}

impl AiComposeNode {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiComposeNode, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Sequence" => AiComposeNode::Sequence(Box::new(AiSequence::new(&__js)?)),
                "Selector" => AiComposeNode::Selector(Box::new(AiSelector::new(&__js)?)),
                "SimpleParallel" => AiComposeNode::SimpleParallel(Box::new(AiSimpleParallel::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiSequence {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub children: Vec<AiFlowNode>,
}

impl AiSequence {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiSequence, LoadError> {
        let __b = AiSequence {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            children: { if !__js["children"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["children"].members() { __list__.push(AiFlowNode::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiSelector {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub children: Vec<AiFlowNode>,
}

impl AiSelector {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiSelector, LoadError> {
        let __b = AiSelector {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            children: { if !__js["children"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["children"].members() { __list__.push(AiFlowNode::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiSimpleParallel {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub finish_mode: i32,
pub main_task: AiTask,
pub background_node: AiFlowNode,
}

impl AiSimpleParallel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiSimpleParallel, LoadError> {
        let __b = AiSimpleParallel {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            finish_mode: match __js["finish_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            main_task: AiTask::new(&__js["main_task"])?,
            background_node: AiFlowNode::new(&__js["background_node"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum AiTask {
  UeWait(Box<AiUeWait>),
  UeWaitBlackboardTime(Box<AiUeWaitBlackboardTime>),
  MoveToTarget(Box<AiMoveToTarget>),
  ChooseSkill(Box<AiChooseSkill>),
  MoveToRandomLocation(Box<AiMoveToRandomLocation>),
  MoveToLocation(Box<AiMoveToLocation>),
  DebugPrint(Box<AiDebugPrint>),
}

impl AiTask {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiTask, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeWait" => AiTask::UeWait(Box::new(AiUeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => AiTask::UeWaitBlackboardTime(Box::new(AiUeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => AiTask::MoveToTarget(Box::new(AiMoveToTarget::new(&__js)?)),
                "ChooseSkill" => AiTask::ChooseSkill(Box::new(AiChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => AiTask::MoveToRandomLocation(Box::new(AiMoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => AiTask::MoveToLocation(Box::new(AiMoveToLocation::new(&__js)?)),
                "DebugPrint" => AiTask::DebugPrint(Box::new(AiDebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeWait {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub wait_time: f32,
pub random_deviation: f32,
}

impl AiUeWait {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeWait, LoadError> {
        let __b = AiUeWait {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            wait_time: match __js["wait_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            random_deviation: match __js["random_deviation"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiUeWaitBlackboardTime {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub blackboard_key: String,
}

impl AiUeWaitBlackboardTime {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiUeWaitBlackboardTime, LoadError> {
        let __b = AiUeWaitBlackboardTime {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            blackboard_key: match __js["blackboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiMoveToTarget {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub target_actor_key: String,
pub acceptable_radius: f32,
}

impl AiMoveToTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiMoveToTarget, LoadError> {
        let __b = AiMoveToTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiChooseSkill {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub target_actor_key: String,
pub result_skill_id_key: String,
}

impl AiChooseSkill {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiChooseSkill, LoadError> {
        let __b = AiChooseSkill {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            result_skill_id_key: match __js["result_skill_id_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiMoveToRandomLocation {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub origin_position_key: String,
pub radius: f32,
}

impl AiMoveToRandomLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiMoveToRandomLocation, LoadError> {
        let __b = AiMoveToRandomLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            origin_position_key: match __js["origin_position_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            radius: match __js["radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiMoveToLocation {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub location: Vector3,
pub acceptable_radius: f32,
}

impl AiMoveToLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiMoveToLocation, LoadError> {
        let __b = AiMoveToLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            location: Vector3::new(&__js["location"])?,
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct AiDebugPrint {
pub id: i32,
pub node_name: String,
pub decorators: Vec<AiDecorator>,
pub services: Vec<AiService>,
pub ignore_restart_self: bool,
pub text: String,
}

impl AiDebugPrint {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<AiDebugPrint, LoadError> {
        let __b = AiDebugPrint {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(AiDecorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(AiService::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            text: match __js["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct BlueprintTbClazz {
    data_list: Vec<std::rc::Rc<BlueprintClazz>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<BlueprintClazz>>,
}

impl BlueprintTbClazz{
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintTbClazz, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = BlueprintTbClazz {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match BlueprintClazz::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            match &*__v2 {
                BlueprintClazz::Interface(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
                BlueprintClazz::NormalClazz(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
                BlueprintClazz::EnumClazz(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
            };
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&BlueprintTbClazz) -> &std::collections::HashMap<String, std::rc::Rc<BlueprintClazz>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&BlueprintTbClazz) -> &Vec<std::rc::Rc<BlueprintClazz>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&BlueprintTbClazz, key: &String) -> std::option::Option<&std::rc::Rc<BlueprintClazz>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub enum BlueprintClazz {
  Interface(Box<BlueprintInterface>),
  NormalClazz(Box<BlueprintNormalClazz>),
  EnumClazz(Box<BlueprintEnumClazz>),
}

impl BlueprintClazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintClazz, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Interface" => BlueprintClazz::Interface(Box::new(BlueprintInterface::new(&__js)?)),
                "NormalClazz" => BlueprintClazz::NormalClazz(Box::new(BlueprintNormalClazz::new(&__js)?)),
                "EnumClazz" => BlueprintClazz::EnumClazz(Box::new(BlueprintEnumClazz::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum BlueprintMethod {
  AbstraceMethod(Box<BlueprintAbstraceMethod>),
  ExternalMethod(Box<BlueprintExternalMethod>),
  BlueprintMethod(Box<BlueprintBlueprintMethod>),
}

impl BlueprintMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintMethod, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "AbstraceMethod" => BlueprintMethod::AbstraceMethod(Box::new(BlueprintAbstraceMethod::new(&__js)?)),
                "ExternalMethod" => BlueprintMethod::ExternalMethod(Box::new(BlueprintExternalMethod::new(&__js)?)),
                "BlueprintMethod" => BlueprintMethod::BlueprintMethod(Box::new(BlueprintBlueprintMethod::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintParamInfo {
pub name: String,
pub r#type: String,
pub is_ref: bool,
}

impl BlueprintParamInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintParamInfo, LoadError> {
        let __b = BlueprintParamInfo {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            r#type: match __js["type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_ref: match __js["is_ref"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintAbstraceMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<BlueprintParamInfo>,
}

impl BlueprintAbstraceMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintAbstraceMethod, LoadError> {
        let __b = BlueprintAbstraceMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(BlueprintParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintExternalMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<BlueprintParamInfo>,
}

impl BlueprintExternalMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintExternalMethod, LoadError> {
        let __b = BlueprintExternalMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(BlueprintParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintBlueprintMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<BlueprintParamInfo>,
}

impl BlueprintBlueprintMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintBlueprintMethod, LoadError> {
        let __b = BlueprintBlueprintMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(BlueprintParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintInterface {
pub name: String,
pub desc: String,
pub parents: Vec<BlueprintClazz>,
pub methods: Vec<BlueprintMethod>,
}

impl BlueprintInterface {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintInterface, LoadError> {
        let __b = BlueprintInterface {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(BlueprintClazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(BlueprintMethod::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintNormalClazz {
pub name: String,
pub desc: String,
pub parents: Vec<BlueprintClazz>,
pub methods: Vec<BlueprintMethod>,
pub is_abstract: bool,
pub fields: Vec<BlueprintField>,
}

impl BlueprintNormalClazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintNormalClazz, LoadError> {
        let __b = BlueprintNormalClazz {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(BlueprintClazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(BlueprintMethod::new(&__e)?); }   __list__},
            is_abstract: match __js["is_abstract"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            fields: { if !__js["fields"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["fields"].members() { __list__.push(BlueprintField::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintField {
pub name: String,
pub r#type: String,
pub desc: String,
}

impl BlueprintField {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintField, LoadError> {
        let __b = BlueprintField {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            r#type: match __js["type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintEnumClazz {
pub name: String,
pub desc: String,
pub parents: Vec<BlueprintClazz>,
pub methods: Vec<BlueprintMethod>,
pub enums: Vec<BlueprintEnumField>,
}

impl BlueprintEnumClazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintEnumClazz, LoadError> {
        let __b = BlueprintEnumClazz {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(BlueprintClazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(BlueprintMethod::new(&__e)?); }   __list__},
            enums: { if !__js["enums"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["enums"].members() { __list__.push(BlueprintEnumField::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BlueprintEnumField {
pub name: String,
pub value: i32,
}

impl BlueprintEnumField {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BlueprintEnumField, LoadError> {
        let __b = BlueprintEnumField {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct BonusTbDrop {
    data_list: Vec<std::rc::Rc<BonusDropInfo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<BonusDropInfo>>,
}

impl BonusTbDrop{
    pub fn new(__js: &json::JsonValue) -> Result<BonusTbDrop, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = BonusTbDrop {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match BonusDropInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&BonusTbDrop) -> &std::collections::HashMap<i32, std::rc::Rc<BonusDropInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&BonusTbDrop) -> &Vec<std::rc::Rc<BonusDropInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&BonusTbDrop, key: &i32) -> std::option::Option<&std::rc::Rc<BonusDropInfo>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct BonusDropInfo {
pub id: i32,
pub desc: String,
pub client_show_items: Vec<BonusShowItemInfo>,
pub bonus: BonusBonus,
}

impl BonusDropInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusDropInfo, LoadError> {
        let __b = BonusDropInfo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            client_show_items: { if !__js["client_show_items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["client_show_items"].members() { __list__.push(BonusShowItemInfo::new(&__e)?); }   __list__},
            bonus: BonusBonus::new(&__js["bonus"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusShowItemInfo {
pub item_id: i32,
pub item_num: i64,
}

impl BonusShowItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusShowItemInfo, LoadError> {
        let __b = BonusShowItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            item_num: match __js["item_num"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum BonusBonus {
  OneItem(Box<BonusOneItem>),
  OneItems(Box<BonusOneItems>),
  Item(Box<BonusItem>),
  Items(Box<BonusItems>),
  CoefficientItem(Box<BonusCoefficientItem>),
  WeightItems(Box<BonusWeightItems>),
  ProbabilityItems(Box<BonusProbabilityItems>),
  MultiBonus(Box<BonusMultiBonus>),
  ProbabilityBonus(Box<BonusProbabilityBonus>),
  WeightBonus(Box<BonusWeightBonus>),
  DropBonus(Box<BonusDropBonus>),
}

impl BonusBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusBonus, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "OneItem" => BonusBonus::OneItem(Box::new(BonusOneItem::new(&__js)?)),
                "OneItems" => BonusBonus::OneItems(Box::new(BonusOneItems::new(&__js)?)),
                "Item" => BonusBonus::Item(Box::new(BonusItem::new(&__js)?)),
                "Items" => BonusBonus::Items(Box::new(BonusItems::new(&__js)?)),
                "CoefficientItem" => BonusBonus::CoefficientItem(Box::new(BonusCoefficientItem::new(&__js)?)),
                "WeightItems" => BonusBonus::WeightItems(Box::new(BonusWeightItems::new(&__js)?)),
                "ProbabilityItems" => BonusBonus::ProbabilityItems(Box::new(BonusProbabilityItems::new(&__js)?)),
                "MultiBonus" => BonusBonus::MultiBonus(Box::new(BonusMultiBonus::new(&__js)?)),
                "ProbabilityBonus" => BonusBonus::ProbabilityBonus(Box::new(BonusProbabilityBonus::new(&__js)?)),
                "WeightBonus" => BonusBonus::WeightBonus(Box::new(BonusWeightBonus::new(&__js)?)),
                "DropBonus" => BonusBonus::DropBonus(Box::new(BonusDropBonus::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusOneItem {
pub item_id: i32,
}

impl BonusOneItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusOneItem, LoadError> {
        let __b = BonusOneItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusOneItems {
pub items: Vec<i32>,
}

impl BonusOneItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusOneItems, LoadError> {
        let __b = BonusOneItems {
            items: { if !__js["items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["items"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusItem {
pub item_id: i32,
pub amount: i32,
}

impl BonusItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusItem, LoadError> {
        let __b = BonusItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            amount: match __js["amount"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusItems {
pub item_list: Vec<BonusItem>,
}

impl BonusItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusItems, LoadError> {
        let __b = BonusItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(BonusItem::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusCoefficientItem {
pub bonus_id: i32,
pub bonus_list: BonusItems,
}

impl BonusCoefficientItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusCoefficientItem, LoadError> {
        let __b = BonusCoefficientItem {
            bonus_id: match __js["bonus_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bonus_list: BonusItems::new(&__js["bonus_list"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusWeightItems {
pub item_list: Vec<BonusWeightItemInfo>,
}

impl BonusWeightItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusWeightItems, LoadError> {
        let __b = BonusWeightItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(BonusWeightItemInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusWeightItemInfo {
pub item_id: i32,
pub num: i32,
pub weight: i32,
}

impl BonusWeightItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusWeightItemInfo, LoadError> {
        let __b = BonusWeightItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            weight: match __js["weight"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusProbabilityItems {
pub item_list: Vec<BonusProbabilityItemInfo>,
}

impl BonusProbabilityItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusProbabilityItems, LoadError> {
        let __b = BonusProbabilityItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(BonusProbabilityItemInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusProbabilityItemInfo {
pub item_id: i32,
pub num: i32,
pub probability: f32,
}

impl BonusProbabilityItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusProbabilityItemInfo, LoadError> {
        let __b = BonusProbabilityItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            probability: match __js["probability"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusMultiBonus {
pub bonuses: Vec<BonusBonus>,
}

impl BonusMultiBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusMultiBonus, LoadError> {
        let __b = BonusMultiBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(BonusBonus::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusProbabilityBonus {
pub bonuses: Vec<BonusProbabilityBonusInfo>,
}

impl BonusProbabilityBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusProbabilityBonus, LoadError> {
        let __b = BonusProbabilityBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(BonusProbabilityBonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusProbabilityBonusInfo {
pub bonus: BonusBonus,
pub probability: f32,
}

impl BonusProbabilityBonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusProbabilityBonusInfo, LoadError> {
        let __b = BonusProbabilityBonusInfo {
            bonus: BonusBonus::new(&__js["bonus"])?,
            probability: match __js["probability"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusWeightBonus {
pub bonuses: Vec<BonusWeightBonusInfo>,
}

impl BonusWeightBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusWeightBonus, LoadError> {
        let __b = BonusWeightBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(BonusWeightBonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusWeightBonusInfo {
pub bonus: BonusBonus,
pub weight: i32,
}

impl BonusWeightBonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusWeightBonusInfo, LoadError> {
        let __b = BonusWeightBonusInfo {
            bonus: BonusBonus::new(&__js["bonus"])?,
            weight: match __js["weight"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct BonusDropBonus {
pub id: i32,
}

impl BonusDropBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<BonusDropBonus, LoadError> {
        let __b = BonusDropBonus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct CommonTbGlobalConfig {
    data: CommonGlobalConfig,
}

impl CommonTbGlobalConfig{
    pub fn new(__js: &json::JsonValue) -> Result<CommonTbGlobalConfig, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match CommonGlobalConfig::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = CommonTbGlobalConfig {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&CommonTbGlobalConfig) -> &CommonGlobalConfig { &self.data }
}



#[allow(non_camel_case_types)]
pub struct CommonGlobalConfig {
pub bag_capacity: i32,
pub bag_capacity_special: i32,
pub bag_temp_expendable_capacity: i32,
pub bag_temp_tool_capacity: i32,
pub bag_init_capacity: i32,
pub quick_bag_capacity: i32,
pub cloth_bag_capacity: i32,
pub cloth_bag_init_capacity: i32,
pub cloth_bag_capacity_special: i32,
pub bag_init_items_drop_id: std::option::Option<i32>,
pub mail_box_capacity: i32,
pub damage_param_c: f32,
pub damage_param_e: f32,
pub damage_param_f: f32,
pub damage_param_d: f32,
pub role_speed: f32,
pub monster_speed: f32,
pub init_energy: i32,
pub init_viality: i32,
pub max_viality: i32,
pub per_viality_recovery_time: i32,
}

impl CommonGlobalConfig {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CommonGlobalConfig, LoadError> {
        let __b = CommonGlobalConfig {
            bag_capacity: match __js["bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_capacity_special: match __js["bag_capacity_special"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_temp_expendable_capacity: match __js["bag_temp_expendable_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_temp_tool_capacity: match __js["bag_temp_tool_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_init_capacity: match __js["bag_init_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quick_bag_capacity: match __js["quick_bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_capacity: match __js["cloth_bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_init_capacity: match __js["cloth_bag_init_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_capacity_special: match __js["cloth_bag_capacity_special"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_init_items_drop_id: if !__js["bag_init_items_drop_id"].is_null() { Some(match __js["bag_init_items_drop_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            mail_box_capacity: match __js["mail_box_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_c: match __js["damage_param_c"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_e: match __js["damage_param_e"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_f: match __js["damage_param_f"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_d: match __js["damage_param_d"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            role_speed: match __js["role_speed"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            monster_speed: match __js["monster_speed"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            init_energy: match __js["init_energy"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            init_viality: match __js["init_viality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max_viality: match __js["max_viality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            per_viality_recovery_time: match __js["per_viality_recovery_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct ErrorTbErrorInfo {
    data_list: Vec<std::rc::Rc<ErrorErrorInfo>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<ErrorErrorInfo>>,
}

impl ErrorTbErrorInfo{
    pub fn new(__js: &json::JsonValue) -> Result<ErrorTbErrorInfo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = ErrorTbErrorInfo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match ErrorErrorInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.code.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&ErrorTbErrorInfo) -> &std::collections::HashMap<String, std::rc::Rc<ErrorErrorInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&ErrorTbErrorInfo) -> &Vec<std::rc::Rc<ErrorErrorInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&ErrorTbErrorInfo, key: &String) -> std::option::Option<&std::rc::Rc<ErrorErrorInfo>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct ErrorErrorInfo {
pub code: String,
pub desc: String,
pub style: ErrorErrorStyle,
}

impl ErrorErrorInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorInfo, LoadError> {
        let __b = ErrorErrorInfo {
            code: match __js["code"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            style: ErrorErrorStyle::new(&__js["style"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum ErrorErrorStyle {
  ErrorStyleTip(Box<ErrorErrorStyleTip>),
  ErrorStyleMsgbox(Box<ErrorErrorStyleMsgbox>),
  ErrorStyleDlgOk(Box<ErrorErrorStyleDlgOk>),
  ErrorStyleDlgOkCancel(Box<ErrorErrorStyleDlgOkCancel>),
}

impl ErrorErrorStyle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorStyle, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "ErrorStyleTip" => ErrorErrorStyle::ErrorStyleTip(Box::new(ErrorErrorStyleTip::new(&__js)?)),
                "ErrorStyleMsgbox" => ErrorErrorStyle::ErrorStyleMsgbox(Box::new(ErrorErrorStyleMsgbox::new(&__js)?)),
                "ErrorStyleDlgOk" => ErrorErrorStyle::ErrorStyleDlgOk(Box::new(ErrorErrorStyleDlgOk::new(&__js)?)),
                "ErrorStyleDlgOkCancel" => ErrorErrorStyle::ErrorStyleDlgOkCancel(Box::new(ErrorErrorStyleDlgOkCancel::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ErrorErrorStyleTip {
}

impl ErrorErrorStyleTip {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorStyleTip, LoadError> {
        let __b = ErrorErrorStyleTip {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ErrorErrorStyleMsgbox {
pub btn_name: String,
pub operation: i32,
}

impl ErrorErrorStyleMsgbox {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorStyleMsgbox, LoadError> {
        let __b = ErrorErrorStyleMsgbox {
            btn_name: match __js["btn_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            operation: match __js["operation"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ErrorErrorStyleDlgOk {
pub btn_name: String,
}

impl ErrorErrorStyleDlgOk {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorStyleDlgOk, LoadError> {
        let __b = ErrorErrorStyleDlgOk {
            btn_name: match __js["btn_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ErrorErrorStyleDlgOkCancel {
pub btn1_name: String,
pub btn2_name: String,
}

impl ErrorErrorStyleDlgOkCancel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorErrorStyleDlgOkCancel, LoadError> {
        let __b = ErrorErrorStyleDlgOkCancel {
            btn1_name: match __js["btn1_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            btn2_name: match __js["btn2_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct ErrorTbCodeInfo {
    data_list: Vec<std::rc::Rc<ErrorCodeInfo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<ErrorCodeInfo>>,
}

impl ErrorTbCodeInfo{
    pub fn new(__js: &json::JsonValue) -> Result<ErrorTbCodeInfo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = ErrorTbCodeInfo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match ErrorCodeInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.code.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&ErrorTbCodeInfo) -> &std::collections::HashMap<i32, std::rc::Rc<ErrorCodeInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&ErrorTbCodeInfo) -> &Vec<std::rc::Rc<ErrorCodeInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&ErrorTbCodeInfo, key: &i32) -> std::option::Option<&std::rc::Rc<ErrorCodeInfo>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct ErrorCodeInfo {
pub code: i32,
pub key: String,
}

impl ErrorCodeInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ErrorCodeInfo, LoadError> {
        let __b = ErrorCodeInfo {
            code: match __js["code"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            key: match __js["key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


/**
 * 道具表
 */
#[allow(non_camel_case_types)]
pub struct ItemTbItem {
    data_list: Vec<std::rc::Rc<ItemItem>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<ItemItem>>,
}

impl ItemTbItem{
    pub fn new(__js: &json::JsonValue) -> Result<ItemTbItem, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = ItemTbItem {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match ItemItem::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&ItemTbItem) -> &std::collections::HashMap<i32, std::rc::Rc<ItemItem>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&ItemTbItem) -> &Vec<std::rc::Rc<ItemItem>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&ItemTbItem, key: &i32) -> std::option::Option<&std::rc::Rc<ItemItem>> { self.data_map.get(key) }
    
}



/**
 * 道具
 */
#[allow(non_camel_case_types)]
pub struct ItemItem {
pub id: i32,
pub name: String,
pub major_type: i32,
pub minor_type: i32,
pub max_pile_num: i32,
pub quality: i32,
pub icon: String,
pub icon_backgroud: String,
pub icon_mask: String,
pub desc: String,
pub show_order: i32,
pub quantifier: String,
pub show_in_bag: bool,
pub min_show_level: i32,
pub batch_usable: bool,
pub progress_time_when_use: f32,
pub show_hint_when_use: bool,
pub droppable: bool,
pub price: std::option::Option<i32>,
pub use_type: i32,
pub level_up_id: std::option::Option<i32>,
}

impl ItemItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemItem, LoadError> {
        let __b = ItemItem {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            major_type: match __js["major_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            minor_type: match __js["minor_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max_pile_num: match __js["max_pile_num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quality: match __js["quality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            icon: match __js["icon"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            icon_backgroud: match __js["icon_backgroud"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            icon_mask: match __js["icon_mask"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            show_order: match __js["show_order"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quantifier: match __js["quantifier"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            show_in_bag: match __js["show_in_bag"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            min_show_level: match __js["min_show_level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            batch_usable: match __js["batch_usable"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            progress_time_when_use: match __js["progress_time_when_use"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            show_hint_when_use: match __js["show_hint_when_use"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            droppable: match __js["droppable"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            price: if !__js["price"].is_null() { Some(match __js["price"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            use_type: match __js["use_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            level_up_id: if !__js["level_up_id"].is_null() { Some(match __js["level_up_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct ItemTbItemFunc {
    data_list: Vec<std::rc::Rc<ItemItemFunction>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<ItemItemFunction>>,
}

impl ItemTbItemFunc{
    pub fn new(__js: &json::JsonValue) -> Result<ItemTbItemFunc, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = ItemTbItemFunc {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match ItemItemFunction::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.minor_type.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&ItemTbItemFunc) -> &std::collections::HashMap<i32, std::rc::Rc<ItemItemFunction>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&ItemTbItemFunc) -> &Vec<std::rc::Rc<ItemItemFunction>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&ItemTbItemFunc, key: &i32) -> std::option::Option<&std::rc::Rc<ItemItemFunction>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct ItemItemFunction {
pub minor_type: i32,
pub func_type: i32,
pub method: String,
pub close_bag_ui: bool,
}

impl ItemItemFunction {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemItemFunction, LoadError> {
        let __b = ItemItemFunction {
            minor_type: match __js["minor_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            func_type: match __js["func_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            method: match __js["method"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            close_bag_ui: match __js["close_bag_ui"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct ItemTbItemExtra {
    data_list: Vec<std::rc::Rc<ItemItemExtra>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<ItemItemExtra>>,
}

impl ItemTbItemExtra{
    pub fn new(__js: &json::JsonValue) -> Result<ItemTbItemExtra, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = ItemTbItemExtra {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match ItemItemExtra::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            match &*__v2 {
                ItemItemExtra::TreasureBox(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                ItemItemExtra::InteractionItem(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                ItemItemExtra::Clothes(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                ItemItemExtra::DesignDrawing(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                ItemItemExtra::Dymmy(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
            };
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&ItemTbItemExtra) -> &std::collections::HashMap<i32, std::rc::Rc<ItemItemExtra>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&ItemTbItemExtra) -> &Vec<std::rc::Rc<ItemItemExtra>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&ItemTbItemExtra, key: &i32) -> std::option::Option<&std::rc::Rc<ItemItemExtra>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub enum ItemItemExtra {
  TreasureBox(Box<ItemTreasureBox>),
  InteractionItem(Box<ItemInteractionItem>),
  Clothes(Box<ItemClothes>),
  DesignDrawing(Box<ItemDesignDrawing>),
  Dymmy(Box<ItemDymmy>),
}

impl ItemItemExtra {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemItemExtra, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "TreasureBox" => ItemItemExtra::TreasureBox(Box::new(ItemTreasureBox::new(&__js)?)),
                "InteractionItem" => ItemItemExtra::InteractionItem(Box::new(ItemInteractionItem::new(&__js)?)),
                "Clothes" => ItemItemExtra::Clothes(Box::new(ItemClothes::new(&__js)?)),
                "DesignDrawing" => ItemItemExtra::DesignDrawing(Box::new(ItemDesignDrawing::new(&__js)?)),
                "Dymmy" => ItemItemExtra::Dymmy(Box::new(ItemDymmy::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemTreasureBox {
pub id: i32,
pub key_item_id: std::option::Option<i32>,
pub open_level: ConditionMinLevel,
pub use_on_obtain: bool,
pub drop_ids: Vec<i32>,
pub choose_list: Vec<ItemChooseOneBonus>,
}

impl ItemTreasureBox {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemTreasureBox, LoadError> {
        let __b = ItemTreasureBox {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            key_item_id: if !__js["key_item_id"].is_null() { Some(match __js["key_item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            open_level: ConditionMinLevel::new(&__js["open_level"])?,
            use_on_obtain: match __js["use_on_obtain"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            drop_ids: { if !__js["drop_ids"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["drop_ids"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            choose_list: { if !__js["choose_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["choose_list"].members() { __list__.push(ItemChooseOneBonus::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum ConditionCondition {
  TimeRange(Box<ConditionTimeRange>),
  MultiRoleCondition(Box<ConditionMultiRoleCondition>),
  GenderLimit(Box<ConditionGenderLimit>),
  MinLevel(Box<ConditionMinLevel>),
  MaxLevel(Box<ConditionMaxLevel>),
  MinMaxLevel(Box<ConditionMinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<ConditionClothesPropertyScoreGreaterThan>),
  ContainsItem(Box<ConditionContainsItem>),
}

impl ConditionCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionCondition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "TimeRange" => ConditionCondition::TimeRange(Box::new(ConditionTimeRange::new(&__js)?)),
                "MultiRoleCondition" => ConditionCondition::MultiRoleCondition(Box::new(ConditionMultiRoleCondition::new(&__js)?)),
                "GenderLimit" => ConditionCondition::GenderLimit(Box::new(ConditionGenderLimit::new(&__js)?)),
                "MinLevel" => ConditionCondition::MinLevel(Box::new(ConditionMinLevel::new(&__js)?)),
                "MaxLevel" => ConditionCondition::MaxLevel(Box::new(ConditionMaxLevel::new(&__js)?)),
                "MinMaxLevel" => ConditionCondition::MinMaxLevel(Box::new(ConditionMinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => ConditionCondition::ClothesPropertyScoreGreaterThan(Box::new(ConditionClothesPropertyScoreGreaterThan::new(&__js)?)),
                "ContainsItem" => ConditionCondition::ContainsItem(Box::new(ConditionContainsItem::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionTimeRange {
pub date_time_range: CommonDateTimeRange,
}

impl ConditionTimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionTimeRange, LoadError> {
        let __b = ConditionTimeRange {
            date_time_range: CommonDateTimeRange::new(&__js["date_time_range"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CommonDateTimeRange {
pub start_time: std::option::Option<i32>,
pub end_time: std::option::Option<i32>,
}

impl CommonDateTimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CommonDateTimeRange, LoadError> {
        let __b = CommonDateTimeRange {
            start_time: if !__js["start_time"].is_null() { Some(match __js["start_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            end_time: if !__js["end_time"].is_null() { Some(match __js["end_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum ConditionRoleCondition {
  MultiRoleCondition(Box<ConditionMultiRoleCondition>),
  GenderLimit(Box<ConditionGenderLimit>),
  MinLevel(Box<ConditionMinLevel>),
  MaxLevel(Box<ConditionMaxLevel>),
  MinMaxLevel(Box<ConditionMinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<ConditionClothesPropertyScoreGreaterThan>),
  ContainsItem(Box<ConditionContainsItem>),
}

impl ConditionRoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionRoleCondition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "MultiRoleCondition" => ConditionRoleCondition::MultiRoleCondition(Box::new(ConditionMultiRoleCondition::new(&__js)?)),
                "GenderLimit" => ConditionRoleCondition::GenderLimit(Box::new(ConditionGenderLimit::new(&__js)?)),
                "MinLevel" => ConditionRoleCondition::MinLevel(Box::new(ConditionMinLevel::new(&__js)?)),
                "MaxLevel" => ConditionRoleCondition::MaxLevel(Box::new(ConditionMaxLevel::new(&__js)?)),
                "MinMaxLevel" => ConditionRoleCondition::MinMaxLevel(Box::new(ConditionMinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => ConditionRoleCondition::ClothesPropertyScoreGreaterThan(Box::new(ConditionClothesPropertyScoreGreaterThan::new(&__js)?)),
                "ContainsItem" => ConditionRoleCondition::ContainsItem(Box::new(ConditionContainsItem::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionMultiRoleCondition {
pub conditions: Vec<ConditionRoleCondition>,
}

impl ConditionMultiRoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionMultiRoleCondition, LoadError> {
        let __b = ConditionMultiRoleCondition {
            conditions: { if !__js["conditions"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["conditions"].members() { __list__.push(ConditionRoleCondition::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum ConditionBoolRoleCondition {
  GenderLimit(Box<ConditionGenderLimit>),
  MinLevel(Box<ConditionMinLevel>),
  MaxLevel(Box<ConditionMaxLevel>),
  MinMaxLevel(Box<ConditionMinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<ConditionClothesPropertyScoreGreaterThan>),
}

impl ConditionBoolRoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionBoolRoleCondition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "GenderLimit" => ConditionBoolRoleCondition::GenderLimit(Box::new(ConditionGenderLimit::new(&__js)?)),
                "MinLevel" => ConditionBoolRoleCondition::MinLevel(Box::new(ConditionMinLevel::new(&__js)?)),
                "MaxLevel" => ConditionBoolRoleCondition::MaxLevel(Box::new(ConditionMaxLevel::new(&__js)?)),
                "MinMaxLevel" => ConditionBoolRoleCondition::MinMaxLevel(Box::new(ConditionMinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => ConditionBoolRoleCondition::ClothesPropertyScoreGreaterThan(Box::new(ConditionClothesPropertyScoreGreaterThan::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionGenderLimit {
pub gender: i32,
}

impl ConditionGenderLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionGenderLimit, LoadError> {
        let __b = ConditionGenderLimit {
            gender: match __js["gender"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionMinLevel {
pub level: i32,
}

impl ConditionMinLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionMinLevel, LoadError> {
        let __b = ConditionMinLevel {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionMaxLevel {
pub level: i32,
}

impl ConditionMaxLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionMaxLevel, LoadError> {
        let __b = ConditionMaxLevel {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionMinMaxLevel {
pub min: i32,
pub max: i32,
}

impl ConditionMinMaxLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionMinMaxLevel, LoadError> {
        let __b = ConditionMinMaxLevel {
            min: match __js["min"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max: match __js["max"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionClothesPropertyScoreGreaterThan {
pub prop: i32,
pub value: i32,
}

impl ConditionClothesPropertyScoreGreaterThan {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionClothesPropertyScoreGreaterThan, LoadError> {
        let __b = ConditionClothesPropertyScoreGreaterThan {
            prop: match __js["prop"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ConditionContainsItem {
pub item_id: i32,
pub num: i32,
pub reverse: bool,
}

impl ConditionContainsItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ConditionContainsItem, LoadError> {
        let __b = ConditionContainsItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            reverse: match __js["reverse"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemChooseOneBonus {
pub drop_id: i32,
pub is_unique: bool,
}

impl ItemChooseOneBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemChooseOneBonus, LoadError> {
        let __b = ItemChooseOneBonus {
            drop_id: match __js["drop_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            is_unique: match __js["is_unique"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemInteractionItem {
pub id: i32,
pub attack_num: std::option::Option<i32>,
pub holding_static_mesh: String,
pub holding_static_mesh_mat: String,
}

impl ItemInteractionItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemInteractionItem, LoadError> {
        let __b = ItemInteractionItem {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            attack_num: if !__js["attack_num"].is_null() { Some(match __js["attack_num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            holding_static_mesh: match __js["holding_static_mesh"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            holding_static_mesh_mat: match __js["holding_static_mesh_mat"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemClothes {
pub id: i32,
pub attack: i32,
pub hp: i64,
pub energy_limit: i32,
pub energy_resume: i32,
}

impl ItemClothes {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemClothes, LoadError> {
        let __b = ItemClothes {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            attack: match __js["attack"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            hp: match __js["hp"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            energy_limit: match __js["energy_limit"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            energy_resume: match __js["energy_resume"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemDesignDrawing {
pub id: i32,
pub learn_component_id: Vec<i32>,
}

impl ItemDesignDrawing {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemDesignDrawing, LoadError> {
        let __b = ItemDesignDrawing {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            learn_component_id: { if !__js["learn_component_id"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["learn_component_id"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct ItemDymmy {
pub id: i32,
pub cost: CostCost,
}

impl ItemDymmy {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<ItemDymmy, LoadError> {
        let __b = ItemDymmy {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cost: CostCost::new(&__js["cost"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum CostCost {
  CostCurrency(Box<CostCostCurrency>),
  CostCurrencies(Box<CostCostCurrencies>),
  CostOneItem(Box<CostCostOneItem>),
  CostItem(Box<CostCostItem>),
  CostItems(Box<CostCostItems>),
}

impl CostCost {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCost, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "CostCurrency" => CostCost::CostCurrency(Box::new(CostCostCurrency::new(&__js)?)),
                "CostCurrencies" => CostCost::CostCurrencies(Box::new(CostCostCurrencies::new(&__js)?)),
                "CostOneItem" => CostCost::CostOneItem(Box::new(CostCostOneItem::new(&__js)?)),
                "CostItem" => CostCost::CostItem(Box::new(CostCostItem::new(&__js)?)),
                "CostItems" => CostCost::CostItems(Box::new(CostCostItems::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CostCostCurrency {
pub r#type: i32,
pub num: i32,
}

impl CostCostCurrency {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCostCurrency, LoadError> {
        let __b = CostCostCurrency {
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CostCostCurrencies {
pub currencies: Vec<CostCostCurrency>,
}

impl CostCostCurrencies {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCostCurrencies, LoadError> {
        let __b = CostCostCurrencies {
            currencies: { if !__js["currencies"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["currencies"].members() { __list__.push(CostCostCurrency::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CostCostOneItem {
pub item_id: i32,
}

impl CostCostOneItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCostOneItem, LoadError> {
        let __b = CostCostOneItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CostCostItem {
pub item_id: i32,
pub amount: i32,
}

impl CostCostItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCostItem, LoadError> {
        let __b = CostCostItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            amount: match __js["amount"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct CostCostItems {
pub item_list: Vec<CostCostItem>,
}

impl CostCostItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<CostCostItems, LoadError> {
        let __b = CostCostItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(CostCostItem::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct L10nTbL10NDemo {
    data_list: Vec<std::rc::Rc<L10nL10NDemo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<L10nL10NDemo>>,
}

impl L10nTbL10NDemo{
    pub fn new(__js: &json::JsonValue) -> Result<L10nTbL10NDemo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = L10nTbL10NDemo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match L10nL10NDemo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&L10nTbL10NDemo) -> &std::collections::HashMap<i32, std::rc::Rc<L10nL10NDemo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&L10nTbL10NDemo) -> &Vec<std::rc::Rc<L10nL10NDemo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&L10nTbL10NDemo, key: &i32) -> std::option::Option<&std::rc::Rc<L10nL10NDemo>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct L10nL10NDemo {
pub id: i32,
pub text: String,
}

impl L10nL10NDemo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<L10nL10NDemo, LoadError> {
        let __b = L10nL10NDemo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            text: { if !__js["text"]["key"].is_string() { return Err(LoadError{}); } match __js["text"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct L10nTbPatchDemo {
    data_list: Vec<std::rc::Rc<L10nPatchDemo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<L10nPatchDemo>>,
}

impl L10nTbPatchDemo{
    pub fn new(__js: &json::JsonValue) -> Result<L10nTbPatchDemo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = L10nTbPatchDemo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match L10nPatchDemo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&L10nTbPatchDemo) -> &std::collections::HashMap<i32, std::rc::Rc<L10nPatchDemo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&L10nTbPatchDemo) -> &Vec<std::rc::Rc<L10nPatchDemo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&L10nTbPatchDemo, key: &i32) -> std::option::Option<&std::rc::Rc<L10nPatchDemo>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct L10nPatchDemo {
pub id: i32,
pub value: i32,
}

impl L10nPatchDemo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<L10nPatchDemo, LoadError> {
        let __b = L10nPatchDemo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct MailTbSystemMail {
    data_list: Vec<std::rc::Rc<MailSystemMail>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<MailSystemMail>>,
}

impl MailTbSystemMail{
    pub fn new(__js: &json::JsonValue) -> Result<MailTbSystemMail, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = MailTbSystemMail {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match MailSystemMail::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&MailTbSystemMail) -> &std::collections::HashMap<i32, std::rc::Rc<MailSystemMail>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&MailTbSystemMail) -> &Vec<std::rc::Rc<MailSystemMail>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&MailTbSystemMail, key: &i32) -> std::option::Option<&std::rc::Rc<MailSystemMail>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct MailSystemMail {
pub id: i32,
pub title: String,
pub sender: String,
pub content: String,
pub award: Vec<i32>,
}

impl MailSystemMail {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<MailSystemMail, LoadError> {
        let __b = MailSystemMail {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            title: match __js["title"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            sender: match __js["sender"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            content: match __js["content"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            award: { if !__js["award"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["award"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct MailTbGlobalMail {
    data_list: Vec<std::rc::Rc<MailGlobalMail>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<MailGlobalMail>>,
}

impl MailTbGlobalMail{
    pub fn new(__js: &json::JsonValue) -> Result<MailTbGlobalMail, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = MailTbGlobalMail {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match MailGlobalMail::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&MailTbGlobalMail) -> &std::collections::HashMap<i32, std::rc::Rc<MailGlobalMail>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&MailTbGlobalMail) -> &Vec<std::rc::Rc<MailGlobalMail>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&MailTbGlobalMail, key: &i32) -> std::option::Option<&std::rc::Rc<MailGlobalMail>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct MailGlobalMail {
pub id: i32,
pub title: String,
pub sender: String,
pub content: String,
pub award: Vec<i32>,
pub all_server: bool,
pub server_list: Vec<i32>,
pub platform: String,
pub channel: String,
pub min_max_level: ConditionMinMaxLevel,
pub register_time: ConditionTimeRange,
pub mail_time: ConditionTimeRange,
}

impl MailGlobalMail {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<MailGlobalMail, LoadError> {
        let __b = MailGlobalMail {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            title: match __js["title"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            sender: match __js["sender"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            content: match __js["content"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            award: { if !__js["award"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["award"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            all_server: match __js["all_server"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            server_list: { if !__js["server_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["server_list"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            platform: match __js["platform"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            channel: match __js["channel"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            min_max_level: ConditionMinMaxLevel::new(&__js["min_max_level"])?,
            register_time: ConditionTimeRange::new(&__js["register_time"])?,
            mail_time: ConditionTimeRange::new(&__js["mail_time"])?,
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct RoleTbRoleLevelExpAttr {
    data_list: Vec<std::rc::Rc<RoleLevelExpAttr>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<RoleLevelExpAttr>>,
}

impl RoleTbRoleLevelExpAttr{
    pub fn new(__js: &json::JsonValue) -> Result<RoleTbRoleLevelExpAttr, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = RoleTbRoleLevelExpAttr {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match RoleLevelExpAttr::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.level.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&RoleTbRoleLevelExpAttr) -> &std::collections::HashMap<i32, std::rc::Rc<RoleLevelExpAttr>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&RoleTbRoleLevelExpAttr) -> &Vec<std::rc::Rc<RoleLevelExpAttr>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&RoleTbRoleLevelExpAttr, key: &i32) -> std::option::Option<&std::rc::Rc<RoleLevelExpAttr>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct RoleLevelExpAttr {
pub level: i32,
pub need_exp: i64,
pub clothes_attrs: Vec<i32>,
}

impl RoleLevelExpAttr {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<RoleLevelExpAttr, LoadError> {
        let __b = RoleLevelExpAttr {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            need_exp: match __js["need_exp"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            clothes_attrs: { if !__js["clothes_attrs"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["clothes_attrs"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct RoleTbRoleLevelBonusCoefficient {
    data_list: Vec<std::rc::Rc<RoleLevelBonus>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<RoleLevelBonus>>,
}

impl RoleTbRoleLevelBonusCoefficient{
    pub fn new(__js: &json::JsonValue) -> Result<RoleTbRoleLevelBonusCoefficient, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = RoleTbRoleLevelBonusCoefficient {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match RoleLevelBonus::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&RoleTbRoleLevelBonusCoefficient) -> &std::collections::HashMap<i32, std::rc::Rc<RoleLevelBonus>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&RoleTbRoleLevelBonusCoefficient) -> &Vec<std::rc::Rc<RoleLevelBonus>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&RoleTbRoleLevelBonusCoefficient, key: &i32) -> std::option::Option<&std::rc::Rc<RoleLevelBonus>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct RoleLevelBonus {
pub id: i32,
pub distinct_bonus_infos: Vec<RoleDistinctBonusInfos>,
}

impl RoleLevelBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<RoleLevelBonus, LoadError> {
        let __b = RoleLevelBonus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            distinct_bonus_infos: { if !__js["distinct_bonus_infos"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["distinct_bonus_infos"].members() { __list__.push(RoleDistinctBonusInfos::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct RoleDistinctBonusInfos {
pub effective_level: i32,
pub bonus_info: Vec<RoleBonusInfo>,
}

impl RoleDistinctBonusInfos {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<RoleDistinctBonusInfos, LoadError> {
        let __b = RoleDistinctBonusInfos {
            effective_level: match __js["effective_level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bonus_info: { if !__js["bonus_info"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonus_info"].members() { __list__.push(RoleBonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct RoleBonusInfo {
pub r#type: i32,
pub coefficient: f32,
}

impl RoleBonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<RoleBonusInfo, LoadError> {
        let __b = RoleBonusInfo {
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            coefficient: match __js["coefficient"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TagTbTestTag {
    data_list: Vec<std::rc::Rc<TagTestTag>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TagTestTag>>,
}

impl TagTbTestTag{
    pub fn new(__js: &json::JsonValue) -> Result<TagTbTestTag, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TagTbTestTag {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TagTestTag::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TagTbTestTag) -> &std::collections::HashMap<i32, std::rc::Rc<TagTestTag>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TagTbTestTag) -> &Vec<std::rc::Rc<TagTestTag>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TagTbTestTag, key: &i32) -> std::option::Option<&std::rc::Rc<TagTestTag>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TagTestTag {
pub id: i32,
pub value: String,
}

impl TagTestTag {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TagTestTag, LoadError> {
        let __b = TagTestTag {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbFullTypes {
    data_list: Vec<std::rc::Rc<TestDemoType2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoType2>>,
}

impl TestTbFullTypes{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbFullTypes, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbFullTypes {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoType2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbFullTypes) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoType2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbFullTypes) -> &Vec<std::rc::Rc<TestDemoType2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbFullTypes, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoType2>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDemoType2 {
pub x4: i32,
pub x1: bool,
pub x2: u8,
pub x3: i16,
pub x5: i64,
pub x6: f32,
pub x7: f64,
pub x8_0: i16,
pub x8: i32,
pub x9: i64,
pub x10: String,
pub x12: TestDemoType1,
pub x13: i32,
pub x14: TestDemoDynamic,
pub s1: String,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
pub t1: i32,
pub k1: Vec<i32>,
pub k2: Vec<i32>,
pub k5: std::collections::HashSet<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<TestDemoE2>,
pub k15: Vec<TestDemoDynamic>,
}

impl TestDemoType2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoType2, LoadError> {
        let __b = TestDemoType2 {
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_u8() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x7: match __js["x7"].as_f64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8_0: match __js["x8_0"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x9: match __js["x9"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x12: TestDemoType1::new(&__js["x12"])?,
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: TestDemoDynamic::new(&__js["x14"])?,
            s1: { if !__js["s1"]["key"].is_string() { return Err(LoadError{}); } match __js["s1"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k2: { if !__js["k2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k5: { if !__js["k5"].is_array() { return Err(LoadError{}); } let mut __set__ = std::collections::HashSet::new(); for __e in __js["k5"].members() { __set__.insert(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __set__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(TestDemoE2::new(&__e)?); }   __list__},
            k15: { if !__js["k15"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k15"].members() { __list__.push(TestDemoDynamic::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDemoType1 {
pub x1: i32,
}

impl TestDemoType1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoType1, LoadError> {
        let __b = TestDemoType1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum TestDemoDynamic {
  DemoD2(Box<TestDemoD2>),
  DemoE1(Box<TestDemoE1>),
  RoleInfo(Box<TestLoginRoleInfo>),
  DemoD5(Box<TestDemoD5>),
}

impl TestDemoDynamic {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoDynamic, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DemoD2" => TestDemoDynamic::DemoD2(Box::new(TestDemoD2::new(&__js)?)),
                "DemoE1" => TestDemoDynamic::DemoE1(Box::new(TestDemoE1::new(&__js)?)),
                "test.login.RoleInfo" => TestDemoDynamic::RoleInfo(Box::new(TestLoginRoleInfo::new(&__js)?)),
                "DemoD5" => TestDemoDynamic::DemoD5(Box::new(TestDemoD5::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDemoD2 {
pub x1: i32,
pub x2: i32,
}

impl TestDemoD2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoD2, LoadError> {
        let __b = TestDemoD2 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum TestDemoD3 {
  DemoE1(Box<TestDemoE1>),
  RoleInfo(Box<TestLoginRoleInfo>),
}

impl TestDemoD3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoD3, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DemoE1" => TestDemoD3::DemoE1(Box::new(TestDemoE1::new(&__js)?)),
                "test.login.RoleInfo" => TestDemoD3::RoleInfo(Box::new(TestLoginRoleInfo::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDemoE1 {
pub x1: i32,
pub x3: i32,
pub x4: i32,
}

impl TestDemoE1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoE1, LoadError> {
        let __b = TestDemoE1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestLoginRoleInfo {
pub x1: i32,
pub x3: i32,
pub role_id: i64,
}

impl TestLoginRoleInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestLoginRoleInfo, LoadError> {
        let __b = TestLoginRoleInfo {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            role_id: match __js["role_id"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDemoD5 {
pub x1: i32,
pub time: TestDateTimeRange,
}

impl TestDemoD5 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoD5, LoadError> {
        let __b = TestDemoD5 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            time: TestDateTimeRange::new(&__js["time"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDateTimeRange {
pub start_time: i32,
pub end_time: i32,
}

impl TestDateTimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDateTimeRange, LoadError> {
        let __b = TestDateTimeRange {
            start_time: match __js["start_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            end_time: match __js["end_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDemoE2 {
pub y1: std::option::Option<i32>,
pub y2: bool,
}

impl TestDemoE2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoE2, LoadError> {
        let __b = TestDemoE2 {
            y1: if !__js["y1"].is_null() { Some(match __js["y1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            y2: match __js["y2"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbSingleton {
    data: TestDemoSingletonType,
}

impl TestTbSingleton{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbSingleton, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match TestDemoSingletonType::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = TestTbSingleton {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&TestTbSingleton) -> &TestDemoSingletonType { &self.data }
}



#[allow(non_camel_case_types)]
pub struct TestDemoSingletonType {
pub id: i32,
pub name: String,
pub date: TestDemoDynamic,
}

impl TestDemoSingletonType {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoSingletonType, LoadError> {
        let __b = TestDemoSingletonType {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: { if !__js["name"]["key"].is_string() { return Err(LoadError{}); } match __js["name"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            date: TestDemoDynamic::new(&__js["date"])?,
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbNotIndexList {
    data_list: Vec<std::rc::Rc<TestNotIndexList>>,
}

impl TestTbNotIndexList{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbNotIndexList, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbNotIndexList {
            data_list : Vec::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestNotIndexList::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
        }
        Ok(t)
    }

    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbNotIndexList) -> &Vec<std::rc::Rc<TestNotIndexList>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbNotIndexList, index: usize) -> &std::rc::Rc<TestNotIndexList> { &self.data_list[index] }
}



#[allow(non_camel_case_types)]
pub struct TestNotIndexList {
pub x: i32,
pub y: i32,
}

impl TestNotIndexList {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestNotIndexList, LoadError> {
        let __b = TestNotIndexList {
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbMultiUnionIndexList {
    data_list: Vec<std::rc::Rc<TestMultiUnionIndexList>>,
}

impl TestTbMultiUnionIndexList{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbMultiUnionIndexList, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbMultiUnionIndexList {
            data_list : Vec::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestMultiUnionIndexList::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
        }
        Ok(t)
    }

    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbMultiUnionIndexList) -> &Vec<std::rc::Rc<TestMultiUnionIndexList>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbMultiUnionIndexList, index: usize) -> &std::rc::Rc<TestMultiUnionIndexList> { &self.data_list[index] }
}



#[allow(non_camel_case_types)]
pub struct TestMultiUnionIndexList {
pub id1: i32,
pub id2: i64,
pub id3: String,
pub num: i32,
pub desc: String,
}

impl TestMultiUnionIndexList {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiUnionIndexList, LoadError> {
        let __b = TestMultiUnionIndexList {
            id1: match __js["id1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            id2: match __js["id2"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            id3: match __js["id3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbMultiIndexList {
    data_list: Vec<std::rc::Rc<TestMultiIndexList>>,
}

impl TestTbMultiIndexList{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbMultiIndexList, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbMultiIndexList {
            data_list : Vec::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestMultiIndexList::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
        }
        Ok(t)
    }

    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbMultiIndexList) -> &Vec<std::rc::Rc<TestMultiIndexList>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbMultiIndexList, index: usize) -> &std::rc::Rc<TestMultiIndexList> { &self.data_list[index] }
}



#[allow(non_camel_case_types)]
pub struct TestMultiIndexList {
pub id1: i32,
pub id2: i64,
pub id3: String,
pub num: i32,
pub desc: String,
}

impl TestMultiIndexList {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiIndexList, LoadError> {
        let __b = TestMultiIndexList {
            id1: match __js["id1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            id2: match __js["id2"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            id3: match __js["id3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDataFromMisc {
    data_list: Vec<std::rc::Rc<TestDemoType2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoType2>>,
}

impl TestTbDataFromMisc{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDataFromMisc, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDataFromMisc {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoType2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDataFromMisc) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoType2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDataFromMisc) -> &Vec<std::rc::Rc<TestDemoType2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDataFromMisc, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoType2>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbMultiRowRecord {
    data_list: Vec<std::rc::Rc<TestMultiRowRecord>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestMultiRowRecord>>,
}

impl TestTbMultiRowRecord{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbMultiRowRecord, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbMultiRowRecord {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestMultiRowRecord::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbMultiRowRecord) -> &std::collections::HashMap<i32, std::rc::Rc<TestMultiRowRecord>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbMultiRowRecord) -> &Vec<std::rc::Rc<TestMultiRowRecord>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbMultiRowRecord, key: &i32) -> std::option::Option<&std::rc::Rc<TestMultiRowRecord>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestMultiRowRecord {
pub id: i32,
pub name: String,
pub one_rows: Vec<TestMultiRowType1>,
pub multi_rows1: Vec<TestMultiRowType1>,
pub multi_rows2: Vec<TestMultiRowType1>,
pub multi_rows4: std::collections::HashMap<i32, TestMultiRowType2>,
pub multi_rows5: Vec<TestMultiRowType3>,
pub multi_rows6: std::collections::HashMap<i32, TestMultiRowType2>,
pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl TestMultiRowRecord {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiRowRecord, LoadError> {
        let __b = TestMultiRowRecord {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            one_rows: { if !__js["one_rows"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["one_rows"].members() { __list__.push(TestMultiRowType1::new(&__e)?); }   __list__},
            multi_rows1: { if !__js["multi_rows1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows1"].members() { __list__.push(TestMultiRowType1::new(&__e)?); }   __list__},
            multi_rows2: { if !__js["multi_rows2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows2"].members() { __list__.push(TestMultiRowType1::new(&__e)?); }   __list__},
            multi_rows4: { if !__js["multi_rows4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows4"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, TestMultiRowType2::new(&__e[1])?); }   __map__},
            multi_rows5: { if !__js["multi_rows5"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows5"].members() { __list__.push(TestMultiRowType3::new(&__e)?); }   __list__},
            multi_rows6: { if !__js["multi_rows6"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows6"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, TestMultiRowType2::new(&__e[1])?); }   __map__},
            multi_rows7: { if !__js["multi_rows7"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows7"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestMultiRowType1 {
pub id: i32,
pub x: i32,
}

impl TestMultiRowType1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiRowType1, LoadError> {
        let __b = TestMultiRowType1 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestMultiRowType2 {
pub id: i32,
pub x: i32,
pub y: f32,
}

impl TestMultiRowType2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiRowType2, LoadError> {
        let __b = TestMultiRowType2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestMultiRowType3 {
pub id: i32,
pub items: Vec<TestMultiRowType1>,
}

impl TestMultiRowType3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiRowType3, LoadError> {
        let __b = TestMultiRowType3 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            items: { if !__js["items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["items"].members() { __list__.push(TestMultiRowType1::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestMultiColumn {
    data_list: Vec<std::rc::Rc<TestTestMultiColumn>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestMultiColumn>>,
}

impl TestTbTestMultiColumn{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestMultiColumn, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestMultiColumn {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestMultiColumn::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestMultiColumn) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestMultiColumn>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestMultiColumn) -> &Vec<std::rc::Rc<TestTestMultiColumn>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestMultiColumn, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestMultiColumn>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestMultiColumn {
pub id: i32,
pub a: TestFoo,
pub b: TestFoo,
pub c: TestFoo,
}

impl TestTestMultiColumn {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestMultiColumn, LoadError> {
        let __b = TestTestMultiColumn {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            a: TestFoo::new(&__js["a"])?,
            b: TestFoo::new(&__js["b"])?,
            c: TestFoo::new(&__js["c"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestFoo {
pub y1: i32,
pub y2: i32,
pub y3: i32,
}

impl TestFoo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestFoo, LoadError> {
        let __b = TestFoo {
            y1: match __js["y1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y2: match __js["y2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y3: match __js["y3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbMultiRowTitle {
    data_list: Vec<std::rc::Rc<TestMultiRowTitle>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestMultiRowTitle>>,
}

impl TestTbMultiRowTitle{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbMultiRowTitle, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbMultiRowTitle {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestMultiRowTitle::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbMultiRowTitle) -> &std::collections::HashMap<i32, std::rc::Rc<TestMultiRowTitle>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbMultiRowTitle) -> &Vec<std::rc::Rc<TestMultiRowTitle>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbMultiRowTitle, key: &i32) -> std::option::Option<&std::rc::Rc<TestMultiRowTitle>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestMultiRowTitle {
pub id: i32,
pub name: String,
pub x1: TestH1,
pub x2_0: std::option::Option<TestH2>,
pub x2: Vec<TestH2>,
pub x3: Vec<TestH2>,
pub x4: Vec<TestH2>,
}

impl TestMultiRowTitle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestMultiRowTitle, LoadError> {
        let __b = TestMultiRowTitle {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x1: TestH1::new(&__js["x1"])?,
            x2_0: if !__js["x2_0"].is_null() { Some(TestH2::new(&__js["x2_0"])?) } else { None },
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x2"].members() { __list__.push(TestH2::new(&__e)?); }   __list__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x3"].members() { __list__.push(TestH2::new(&__e)?); }   __list__},
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x4"].members() { __list__.push(TestH2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestH1 {
pub y2: TestH2,
pub y3: i32,
}

impl TestH1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestH1, LoadError> {
        let __b = TestH1 {
            y2: TestH2::new(&__js["y2"])?,
            y3: match __js["y3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestH2 {
pub z2: i32,
pub z3: i32,
}

impl TestH2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestH2, LoadError> {
        let __b = TestH2 {
            z2: match __js["z2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            z3: match __js["z3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestNull {
    data_list: Vec<std::rc::Rc<TestTestNull>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestNull>>,
}

impl TestTbTestNull{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestNull, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestNull {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestNull::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestNull) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestNull>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestNull) -> &Vec<std::rc::Rc<TestTestNull>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestNull, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestNull>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestNull {
pub id: i32,
pub x1: std::option::Option<i32>,
pub x2: std::option::Option<i32>,
pub x3: std::option::Option<TestDemoType1>,
pub x4: std::option::Option<TestDemoDynamic>,
pub s1: std::option::Option<String>,
pub s2: std::option::Option<String>,
}

impl TestTestNull {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestNull, LoadError> {
        let __b = TestTestNull {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: if !__js["x1"].is_null() { Some(match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            x2: if !__js["x2"].is_null() { Some(match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            x3: if !__js["x3"].is_null() { Some(TestDemoType1::new(&__js["x3"])?) } else { None },
            x4: if !__js["x4"].is_null() { Some(TestDemoDynamic::new(&__js["x4"])?) } else { None },
            s1: if !__js["s1"].is_null() { Some(match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }) } else { None },
            s2: if !__js["s2"].is_null() { Some({ if !__js["s2"]["key"].is_string() { return Err(LoadError{}); } match __js["s2"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } }) } else { None },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDemoPrimitive {
    data_list: Vec<std::rc::Rc<TestDemoPrimitiveTypesTable>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoPrimitiveTypesTable>>,
}

impl TestTbDemoPrimitive{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoPrimitive, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoPrimitive {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoPrimitiveTypesTable::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoPrimitive) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoPrimitiveTypesTable>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoPrimitive) -> &Vec<std::rc::Rc<TestDemoPrimitiveTypesTable>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoPrimitive, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoPrimitiveTypesTable>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDemoPrimitiveTypesTable {
pub x1: bool,
pub x2: u8,
pub x3: i16,
pub x4: i32,
pub x5: i64,
pub x6: f32,
pub x7: f64,
pub s1: String,
pub s2: String,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
pub t1: i32,
}

impl TestDemoPrimitiveTypesTable {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoPrimitiveTypesTable, LoadError> {
        let __b = TestDemoPrimitiveTypesTable {
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_u8() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x7: match __js["x7"].as_f64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s1: match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            s2: { if !__js["s2"]["key"].is_string() { return Err(LoadError{}); } match __js["s2"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestString {
    data_list: Vec<std::rc::Rc<TestTestString>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestString>>,
}

impl TestTbTestString{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestString, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestString {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestString::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestString) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestString>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestString) -> &Vec<std::rc::Rc<TestTestString>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestString, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestString>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestString {
pub id: i32,
pub s1: String,
pub cs1: TestCompactString,
pub cs2: TestCompactString,
}

impl TestTestString {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestString, LoadError> {
        let __b = TestTestString {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s1: match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            cs1: TestCompactString::new(&__js["cs1"])?,
            cs2: TestCompactString::new(&__js["cs2"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestCompactString {
pub id: i32,
pub s2: String,
pub s3: String,
}

impl TestCompactString {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestCompactString, LoadError> {
        let __b = TestCompactString {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s2: match __js["s2"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            s3: match __js["s3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDemoGroup {
    data_list: Vec<std::rc::Rc<TestDemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>>,
}

impl TestTbDemoGroup{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoGroup, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoGroup {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoGroup) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoGroup) -> &Vec<std::rc::Rc<TestDemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoGroup, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoGroup>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDemoGroup {
pub id: i32,
pub x1: i32,
pub x2: i32,
pub x3: i32,
pub x4: i32,
pub x5: TestInnerGroup,
}

impl TestDemoGroup {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDemoGroup, LoadError> {
        let __b = TestDemoGroup {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: TestInnerGroup::new(&__js["x5"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestInnerGroup {
pub y1: i32,
pub y2: i32,
pub y3: i32,
pub y4: i32,
}

impl TestInnerGroup {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestInnerGroup, LoadError> {
        let __b = TestInnerGroup {
            y1: match __js["y1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y2: match __js["y2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y3: match __js["y3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y4: match __js["y4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDemoGroup_C {
    data_list: Vec<std::rc::Rc<TestDemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>>,
}

impl TestTbDemoGroup_C{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoGroup_C, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoGroup_C {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoGroup_C) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoGroup_C) -> &Vec<std::rc::Rc<TestDemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoGroup_C, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoGroup>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbDemoGroup_S {
    data_list: Vec<std::rc::Rc<TestDemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>>,
}

impl TestTbDemoGroup_S{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoGroup_S, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoGroup_S {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoGroup_S) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoGroup_S) -> &Vec<std::rc::Rc<TestDemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoGroup_S, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoGroup>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbDemoGroup_E {
    data_list: Vec<std::rc::Rc<TestDemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>>,
}

impl TestTbDemoGroup_E{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoGroup_E, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoGroup_E {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoGroup_E) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoGroup_E) -> &Vec<std::rc::Rc<TestDemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoGroup_E, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoGroup>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbTestGlobal {
    data: TestTestGlobal,
}

impl TestTbTestGlobal{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestGlobal, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match TestTestGlobal::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = TestTbTestGlobal {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&TestTbTestGlobal) -> &TestTestGlobal { &self.data }
}



#[allow(non_camel_case_types)]
pub struct TestTestGlobal {
pub unlock_equip: i32,
pub unlock_hero: i32,
}

impl TestTestGlobal {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestGlobal, LoadError> {
        let __b = TestTestGlobal {
            unlock_equip: match __js["unlock_equip"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            unlock_hero: match __js["unlock_hero"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestBeRef {
    data_list: Vec<std::rc::Rc<TestTestBeRef>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestBeRef>>,
}

impl TestTbTestBeRef{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestBeRef, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestBeRef {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestBeRef::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestBeRef) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestBeRef>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestBeRef) -> &Vec<std::rc::Rc<TestTestBeRef>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestBeRef, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestBeRef>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestBeRef {
pub id: i32,
pub count: i32,
}

impl TestTestBeRef {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestBeRef, LoadError> {
        let __b = TestTestBeRef {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            count: match __js["count"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestBeRef2 {
    data_list: Vec<std::rc::Rc<TestTestBeRef>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestBeRef>>,
}

impl TestTbTestBeRef2{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestBeRef2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestBeRef2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestBeRef::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestBeRef2) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestBeRef>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestBeRef2) -> &Vec<std::rc::Rc<TestTestBeRef>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestBeRef2, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestBeRef>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbTestRef {
    data_list: Vec<std::rc::Rc<TestTestRef>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestRef>>,
}

impl TestTbTestRef{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestRef, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestRef {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestRef::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestRef) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestRef>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestRef) -> &Vec<std::rc::Rc<TestTestRef>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestRef, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestRef>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestRef {
pub id: i32,
pub x1: i32,
pub x1_2: i32,
pub x2: i32,
pub x3: i32,
pub a1: Vec<i32>,
pub a2: Vec<i32>,
pub b1: Vec<i32>,
pub b2: Vec<i32>,
pub c1: std::collections::HashSet<i32>,
pub c2: std::collections::HashSet<i32>,
pub d1: std::collections::HashMap<i32, i32>,
pub d2: std::collections::HashMap<i32, i32>,
pub e1: i32,
pub e2: i64,
pub e3: String,
pub f1: i32,
pub f2: i64,
pub f3: String,
}

impl TestTestRef {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestRef, LoadError> {
        let __b = TestTestRef {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1_2: match __js["x1_2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            a1: { if !__js["a1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["a1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            a2: { if !__js["a2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["a2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            b1: { if !__js["b1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["b1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            b2: { if !__js["b2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["b2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            c1: { if !__js["c1"].is_array() { return Err(LoadError{}); } let mut __set__ = std::collections::HashSet::new(); for __e in __js["c1"].members() { __set__.insert(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __set__},
            c2: { if !__js["c2"].is_array() { return Err(LoadError{}); } let mut __set__ = std::collections::HashSet::new(); for __e in __js["c2"].members() { __set__.insert(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __set__},
            d1: { if !__js["d1"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["d1"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            d2: { if !__js["d2"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["d2"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            e1: match __js["e1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            e2: match __js["e2"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            e3: match __js["e3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            f1: match __js["f1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            f2: match __js["f2"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            f3: match __js["f3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestSize {
    data_list: Vec<std::rc::Rc<TestTestSize>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestSize>>,
}

impl TestTbTestSize{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestSize, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestSize {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestSize::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestSize) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestSize>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestSize) -> &Vec<std::rc::Rc<TestTestSize>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestSize, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestSize>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestSize {
pub id: i32,
pub x1: Vec<i32>,
pub x2: Vec<i32>,
pub x3: std::collections::HashSet<i32>,
pub x4: std::collections::HashMap<i32, i32>,
}

impl TestTestSize {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestSize, LoadError> {
        let __b = TestTestSize {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: { if !__js["x1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __set__ = std::collections::HashSet::new(); for __e in __js["x3"].members() { __set__.insert(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __set__},
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x4"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestSet {
    data_list: Vec<std::rc::Rc<TestTestSet>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestSet>>,
}

impl TestTbTestSet{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestSet, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestSet {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestSet::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestSet) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestSet>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestSet) -> &Vec<std::rc::Rc<TestTestSet>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestSet, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestSet>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestSet {
pub id: i32,
pub x0: String,
pub x1: Vec<i32>,
pub x2: Vec<i64>,
pub x3: Vec<String>,
pub x4: Vec<i32>,
}

impl TestTestSet {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestSet, LoadError> {
        let __b = TestTestSet {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x0: match __js["x0"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x1: { if !__js["x1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x2"].members() { __list__.push(match __e.as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x3"].members() { __list__.push(match __e.as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }); }   __list__},
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x4"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDetectCsvEncoding {
    data_list: Vec<std::rc::Rc<TestDetectEncoding>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDetectEncoding>>,
}

impl TestTbDetectCsvEncoding{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDetectCsvEncoding, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDetectCsvEncoding {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDetectEncoding::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDetectCsvEncoding) -> &std::collections::HashMap<i32, std::rc::Rc<TestDetectEncoding>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDetectCsvEncoding) -> &Vec<std::rc::Rc<TestDetectEncoding>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDetectCsvEncoding, key: &i32) -> std::option::Option<&std::rc::Rc<TestDetectEncoding>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDetectEncoding {
pub id: i32,
pub name: String,
}

impl TestDetectEncoding {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDetectEncoding, LoadError> {
        let __b = TestDetectEncoding {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbItem2 {
    data_list: Vec<std::rc::Rc<TestItemBase>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestItemBase>>,
}

impl TestTbItem2{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbItem2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbItem2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestItemBase::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            match &*__v2 {
                TestItemBase::Item(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                TestItemBase::Equipment(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                TestItemBase::Decorator(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
            };
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbItem2) -> &std::collections::HashMap<i32, std::rc::Rc<TestItemBase>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbItem2) -> &Vec<std::rc::Rc<TestItemBase>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbItem2, key: &i32) -> std::option::Option<&std::rc::Rc<TestItemBase>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub enum TestItemBase {
  Item(Box<TestItem>),
  Equipment(Box<TestEquipment>),
  Decorator(Box<TestDecorator>),
}

impl TestItemBase {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestItemBase, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Item" => TestItemBase::Item(Box::new(TestItem::new(&__js)?)),
                "Equipment" => TestItemBase::Equipment(Box::new(TestEquipment::new(&__js)?)),
                "Decorator" => TestItemBase::Decorator(Box::new(TestDecorator::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestItem {
pub id: i32,
pub name: String,
pub desc: String,
pub num: i32,
pub price: i32,
}

impl TestItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestItem, LoadError> {
        let __b = TestItem {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            price: match __js["price"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestEquipment {
pub id: i32,
pub name: String,
pub desc: String,
pub attr: i32,
pub value: i32,
}

impl TestEquipment {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestEquipment, LoadError> {
        let __b = TestEquipment {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            attr: match __js["attr"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestDecorator {
pub id: i32,
pub name: String,
pub desc: String,
pub duration: i32,
}

impl TestDecorator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDecorator, LoadError> {
        let __b = TestDecorator {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            duration: match __js["duration"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDefineFromExcel {
    data_list: Vec<std::rc::Rc<TestDefineFromExcel>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDefineFromExcel>>,
}

impl TestTbDefineFromExcel{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDefineFromExcel, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDefineFromExcel {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDefineFromExcel::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDefineFromExcel) -> &std::collections::HashMap<i32, std::rc::Rc<TestDefineFromExcel>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDefineFromExcel) -> &Vec<std::rc::Rc<TestDefineFromExcel>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDefineFromExcel, key: &i32) -> std::option::Option<&std::rc::Rc<TestDefineFromExcel>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDefineFromExcel {
pub id: i32,
pub x1: bool,
pub x5: i64,
pub x6: f32,
pub x8: i32,
pub x10: String,
pub x13: i32,
pub x14: TestDemoDynamic,
pub x15: TestShape,
pub v2: Vector2,
pub t1: i32,
pub k1: Vec<i32>,
pub k2: Vec<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<TestDemoE2>,
}

impl TestDefineFromExcel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDefineFromExcel, LoadError> {
        let __b = TestDefineFromExcel {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: TestDemoDynamic::new(&__js["x14"])?,
            x15: TestShape::new(&__js["x15"])?,
            v2: Vector2::new(&__js["v2"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k2: { if !__js["k2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(TestDemoE2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum TestShape {
  Circle(Box<TestCircle>),
  Rectangle(Box<TestRectangle>),
}

impl TestShape {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestShape, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Circle" => TestShape::Circle(Box::new(TestCircle::new(&__js)?)),
                "Rectangle" => TestShape::Rectangle(Box::new(TestRectangle::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




/**
 * 圆
 */
#[allow(non_camel_case_types)]
pub struct TestCircle {
pub radius: f32,
}

impl TestCircle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestCircle, LoadError> {
        let __b = TestCircle {
            radius: match __js["radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




/**
 * 矩形
 */
#[allow(non_camel_case_types)]
pub struct TestRectangle {
pub width: f32,
pub height: f32,
}

impl TestRectangle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestRectangle, LoadError> {
        let __b = TestRectangle {
            width: match __js["width"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            height: match __js["height"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDefineFromExcelOne {
    data: TestDefineFromExcelOne,
}

impl TestTbDefineFromExcelOne{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDefineFromExcelOne, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match TestDefineFromExcelOne::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = TestTbDefineFromExcelOne {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&TestTbDefineFromExcelOne) -> &TestDefineFromExcelOne { &self.data }
}



#[allow(non_camel_case_types)]
pub struct TestDefineFromExcelOne {
pub unlock_equip: i32,
pub unlock_hero: i32,
pub default_avatar: String,
pub default_item: String,
}

impl TestDefineFromExcelOne {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDefineFromExcelOne, LoadError> {
        let __b = TestDefineFromExcelOne {
            unlock_equip: match __js["unlock_equip"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            unlock_hero: match __js["unlock_hero"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            default_avatar: match __js["default_avatar"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            default_item: match __js["default_item"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestIndex {
    data_list: Vec<std::rc::Rc<TestTestIndex>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestIndex>>,
}

impl TestTbTestIndex{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestIndex, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestIndex {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestIndex::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestIndex) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestIndex>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestIndex) -> &Vec<std::rc::Rc<TestTestIndex>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestIndex, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestIndex>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestIndex {
pub id: i32,
pub eles: Vec<TestDemoType1>,
}

impl TestTestIndex {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestIndex, LoadError> {
        let __b = TestTestIndex {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            eles: { if !__js["eles"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["eles"].members() { __list__.push(TestDemoType1::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestMap {
    data_list: Vec<std::rc::Rc<TestTestMap>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestMap>>,
}

impl TestTbTestMap{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestMap, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestMap {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestMap::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestMap) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestMap>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestMap) -> &Vec<std::rc::Rc<TestTestMap>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestMap, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestMap>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestMap {
pub id: i32,
pub x1: std::collections::HashMap<i32, i32>,
pub x2: std::collections::HashMap<i64, i32>,
pub x3: std::collections::HashMap<String, i32>,
pub x4: std::collections::HashMap<i32, i32>,
}

impl TestTestMap {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestMap, LoadError> {
        let __b = TestTestMap {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: { if !__js["x1"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x1"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x2"].members() { __map__.insert(match __e[0].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x3"].members() { __map__.insert(match __e[0].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x4"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbExcelFromJson {
    data_list: Vec<std::rc::Rc<TestExcelFromJson>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestExcelFromJson>>,
}

impl TestTbExcelFromJson{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbExcelFromJson, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbExcelFromJson {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestExcelFromJson::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbExcelFromJson) -> &std::collections::HashMap<i32, std::rc::Rc<TestExcelFromJson>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbExcelFromJson) -> &Vec<std::rc::Rc<TestExcelFromJson>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbExcelFromJson, key: &i32) -> std::option::Option<&std::rc::Rc<TestExcelFromJson>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestExcelFromJson {
pub x4: i32,
pub x1: bool,
pub x5: i64,
pub x6: f32,
pub s1: String,
pub s2: String,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
pub t1: i32,
pub x12: TestDemoType1,
pub x13: i32,
pub x14: TestDemoDynamic,
pub k1: Vec<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<TestDemoE2>,
pub k15: Vec<TestDemoDynamic>,
}

impl TestExcelFromJson {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestExcelFromJson, LoadError> {
        let __b = TestExcelFromJson {
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s1: match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            s2: { if !__js["s2"]["key"].is_string() { return Err(LoadError{}); } match __js["s2"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x12: TestDemoType1::new(&__js["x12"])?,
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: TestDemoDynamic::new(&__js["x14"])?,
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(TestDemoE2::new(&__e)?); }   __list__},
            k15: { if !__js["k15"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k15"].members() { __list__.push(TestDemoDynamic::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbCompositeJsonTable1 {
    data_list: Vec<std::rc::Rc<TestCompositeJsonTable1>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestCompositeJsonTable1>>,
}

impl TestTbCompositeJsonTable1{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbCompositeJsonTable1, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbCompositeJsonTable1 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestCompositeJsonTable1::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbCompositeJsonTable1) -> &std::collections::HashMap<i32, std::rc::Rc<TestCompositeJsonTable1>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbCompositeJsonTable1) -> &Vec<std::rc::Rc<TestCompositeJsonTable1>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbCompositeJsonTable1, key: &i32) -> std::option::Option<&std::rc::Rc<TestCompositeJsonTable1>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestCompositeJsonTable1 {
pub id: i32,
pub x: String,
}

impl TestCompositeJsonTable1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestCompositeJsonTable1, LoadError> {
        let __b = TestCompositeJsonTable1 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbCompositeJsonTable2 {
    data_list: Vec<std::rc::Rc<TestCompositeJsonTable2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestCompositeJsonTable2>>,
}

impl TestTbCompositeJsonTable2{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbCompositeJsonTable2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbCompositeJsonTable2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestCompositeJsonTable2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbCompositeJsonTable2) -> &std::collections::HashMap<i32, std::rc::Rc<TestCompositeJsonTable2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbCompositeJsonTable2) -> &Vec<std::rc::Rc<TestCompositeJsonTable2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbCompositeJsonTable2, key: &i32) -> std::option::Option<&std::rc::Rc<TestCompositeJsonTable2>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestCompositeJsonTable2 {
pub id: i32,
pub y: i32,
}

impl TestCompositeJsonTable2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestCompositeJsonTable2, LoadError> {
        let __b = TestCompositeJsonTable2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbCompositeJsonTable3 {
    data: TestCompositeJsonTable3,
}

impl TestTbCompositeJsonTable3{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbCompositeJsonTable3, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match TestCompositeJsonTable3::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = TestTbCompositeJsonTable3 {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&TestTbCompositeJsonTable3) -> &TestCompositeJsonTable3 { &self.data }
}



#[allow(non_camel_case_types)]
pub struct TestCompositeJsonTable3 {
pub a: i32,
pub b: i32,
}

impl TestCompositeJsonTable3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestCompositeJsonTable3, LoadError> {
        let __b = TestCompositeJsonTable3 {
            a: match __js["a"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            b: match __js["b"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbExcelFromJsonMultiRow {
    data_list: Vec<std::rc::Rc<TestExcelFromJsonMultiRow>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestExcelFromJsonMultiRow>>,
}

impl TestTbExcelFromJsonMultiRow{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbExcelFromJsonMultiRow, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbExcelFromJsonMultiRow {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestExcelFromJsonMultiRow::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbExcelFromJsonMultiRow) -> &std::collections::HashMap<i32, std::rc::Rc<TestExcelFromJsonMultiRow>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbExcelFromJsonMultiRow) -> &Vec<std::rc::Rc<TestExcelFromJsonMultiRow>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbExcelFromJsonMultiRow, key: &i32) -> std::option::Option<&std::rc::Rc<TestExcelFromJsonMultiRow>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestExcelFromJsonMultiRow {
pub id: i32,
pub x: i32,
pub items: Vec<TestTestRow>,
}

impl TestExcelFromJsonMultiRow {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestExcelFromJsonMultiRow, LoadError> {
        let __b = TestExcelFromJsonMultiRow {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            items: { if !__js["items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["items"].members() { __list__.push(TestTestRow::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestTestRow {
pub x: i32,
pub y: bool,
pub z: String,
pub a: TestTest3,
pub b: Vec<i32>,
}

impl TestTestRow {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestRow, LoadError> {
        let __b = TestTestRow {
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            z: match __js["z"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            a: TestTest3::new(&__js["a"])?,
            b: { if !__js["b"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["b"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestTest3 {
pub x: i32,
pub y: i32,
}

impl TestTest3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTest3, LoadError> {
        let __b = TestTest3 {
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestSep {
    data_list: Vec<std::rc::Rc<TestTestSep>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestSep>>,
}

impl TestTbTestSep{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestSep, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestSep {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestSep::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestSep) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestSep>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestSep) -> &Vec<std::rc::Rc<TestTestSep>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestSep, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestSep>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestSep {
pub id: i32,
pub x1: String,
pub x2: TestSepBean1,
pub x3: TestSepVector,
pub x4: Vec<TestSepVector>,
pub x5: Vec<TestSepBean1>,
pub x6: Vec<TestSepBean1>,
}

impl TestTestSep {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestSep, LoadError> {
        let __b = TestTestSep {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: { if !__js["x1"]["key"].is_string() { return Err(LoadError{}); } match __js["x1"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            x2: TestSepBean1::new(&__js["x2"])?,
            x3: TestSepVector::new(&__js["x3"])?,
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x4"].members() { __list__.push(TestSepVector::new(&__e)?); }   __list__},
            x5: { if !__js["x5"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x5"].members() { __list__.push(TestSepBean1::new(&__e)?); }   __list__},
            x6: { if !__js["x6"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x6"].members() { __list__.push(TestSepBean1::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestSepBean1 {
pub a: i32,
pub b: i32,
pub c: String,
}

impl TestSepBean1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestSepBean1, LoadError> {
        let __b = TestSepBean1 {
            a: match __js["a"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            b: match __js["b"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            c: match __js["c"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestSepVector {
pub x: i32,
pub y: i32,
pub z: i32,
}

impl TestSepVector {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestSepVector, LoadError> {
        let __b = TestSepVector {
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            z: match __js["z"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestScriptableObject {
    data_list: Vec<std::rc::Rc<TestTestScriptableObject>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestScriptableObject>>,
}

impl TestTbTestScriptableObject{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestScriptableObject, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestScriptableObject {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestScriptableObject::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestScriptableObject) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestScriptableObject>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestScriptableObject) -> &Vec<std::rc::Rc<TestTestScriptableObject>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestScriptableObject, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestScriptableObject>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestScriptableObject {
pub id: i32,
pub desc: String,
pub rate: f32,
pub num: i32,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
}

impl TestTestScriptableObject {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestScriptableObject, LoadError> {
        let __b = TestTestScriptableObject {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            rate: match __js["rate"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestExternalType {
    data_list: Vec<std::rc::Rc<TestTestExternalType>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestExternalType>>,
}

impl TestTbTestExternalType{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestExternalType, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestExternalType {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestExternalType::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestExternalType) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestExternalType>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestExternalType) -> &Vec<std::rc::Rc<TestTestExternalType>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestExternalType, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestExternalType>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestExternalType {
pub id: i32,
pub audio_type: i32,
pub color: TestColor,
}

impl TestTestExternalType {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestExternalType, LoadError> {
        let __b = TestTestExternalType {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            audio_type: match __js["audio_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            color: TestColor::new(&__js["color"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct TestColor {
pub r: f32,
pub g: f32,
pub b: f32,
pub a: f32,
}

impl TestColor {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestColor, LoadError> {
        let __b = TestColor {
            r: match __js["r"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            g: match __js["g"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            b: match __js["b"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            a: match __js["a"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbDemoGroupDefineFromExcel {
    data_list: Vec<std::rc::Rc<TestDemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>>,
}

impl TestTbDemoGroupDefineFromExcel{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDemoGroupDefineFromExcel, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDemoGroupDefineFromExcel {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDemoGroupDefineFromExcel) -> &std::collections::HashMap<i32, std::rc::Rc<TestDemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDemoGroupDefineFromExcel) -> &Vec<std::rc::Rc<TestDemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDemoGroupDefineFromExcel, key: &i32) -> std::option::Option<&std::rc::Rc<TestDemoGroup>> { self.data_map.get(key) }
    
}

#[allow(non_camel_case_types)]
pub struct TestTbDefineFromExcel2 {
    data_list: Vec<std::rc::Rc<TestDefineFromExcel2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestDefineFromExcel2>>,
}

impl TestTbDefineFromExcel2{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbDefineFromExcel2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbDefineFromExcel2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestDefineFromExcel2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbDefineFromExcel2) -> &std::collections::HashMap<i32, std::rc::Rc<TestDefineFromExcel2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbDefineFromExcel2) -> &Vec<std::rc::Rc<TestDefineFromExcel2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbDefineFromExcel2, key: &i32) -> std::option::Option<&std::rc::Rc<TestDefineFromExcel2>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestDefineFromExcel2 {
pub id: i32,
pub x1: bool,
pub x5: i64,
pub x6: f32,
pub x8: i32,
pub x10: String,
pub x13: i32,
pub x14: TestDemoDynamic,
pub x15: TestShape,
pub v2: Vector2,
pub t1: i32,
pub k1: Vec<i32>,
pub k2: Vec<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<TestDemoE2>,
}

impl TestDefineFromExcel2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestDefineFromExcel2, LoadError> {
        let __b = TestDefineFromExcel2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: TestDemoDynamic::new(&__js["x14"])?,
            x15: TestShape::new(&__js["x15"])?,
            v2: Vector2::new(&__js["v2"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k2: { if !__js["k2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(TestDemoE2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestExcelBean {
    data_list: Vec<std::rc::Rc<TestTestExcelBean1>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestExcelBean1>>,
}

impl TestTbTestExcelBean{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestExcelBean, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestExcelBean {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestExcelBean1::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x1.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestExcelBean) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestExcelBean1>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestExcelBean) -> &Vec<std::rc::Rc<TestTestExcelBean1>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestExcelBean, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestExcelBean1>> { self.data_map.get(key) }
    
}



/**
 * 这是个测试excel结构
 */
#[allow(non_camel_case_types)]
pub struct TestTestExcelBean1 {
pub x1: i32,
pub x2: String,
pub x3: i32,
pub x4: f32,
}

impl TestTestExcelBean1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestExcelBean1, LoadError> {
        let __b = TestTestExcelBean1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct TestTbTestDesc {
    data_list: Vec<std::rc::Rc<TestTestDesc>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<TestTestDesc>>,
}

impl TestTbTestDesc{
    pub fn new(__js: &json::JsonValue) -> Result<TestTbTestDesc, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = TestTbTestDesc {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match TestTestDesc::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&TestTbTestDesc) -> &std::collections::HashMap<i32, std::rc::Rc<TestTestDesc>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&TestTbTestDesc) -> &Vec<std::rc::Rc<TestTestDesc>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&TestTbTestDesc, key: &i32) -> std::option::Option<&std::rc::Rc<TestTestDesc>> { self.data_map.get(key) }
    
}



#[allow(non_camel_case_types)]
pub struct TestTestDesc {
pub id: i32,
pub name: String,
pub a1: i32,
pub a2: i32,
pub x1: TestH1,
pub x2: Vec<TestH2>,
pub x3: Vec<TestH2>,
}

impl TestTestDesc {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<TestTestDesc, LoadError> {
        let __b = TestTestDesc {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            a1: match __js["a1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            a2: match __js["a2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: TestH1::new(&__js["x1"])?,
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x2"].members() { __list__.push(TestH2::new(&__e)?); }   __list__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x3"].members() { __list__.push(TestH2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}



type JsonLoader = fn(&str) -> Result<json::JsonValue, LoadError>;

#[allow(non_camel_case_types)]
pub struct Tables {

    pub tbblackboard: AiTbBlackboard,

    pub tbbehaviortree: AiTbBehaviorTree,

    pub tbclazz: BlueprintTbClazz,

    pub tbdrop: BonusTbDrop,

    pub tbglobalconfig: CommonTbGlobalConfig,

    pub tberrorinfo: ErrorTbErrorInfo,

    pub tbcodeinfo: ErrorTbCodeInfo,

    /**
     * 道具表
     */
    pub tbitem: ItemTbItem,

    pub tbitemfunc: ItemTbItemFunc,

    pub tbitemextra: ItemTbItemExtra,

    pub tbl10ndemo: L10nTbL10NDemo,

    pub tbpatchdemo: L10nTbPatchDemo,

    pub tbsystemmail: MailTbSystemMail,

    pub tbglobalmail: MailTbGlobalMail,

    pub tbrolelevelexpattr: RoleTbRoleLevelExpAttr,

    pub tbrolelevelbonuscoefficient: RoleTbRoleLevelBonusCoefficient,

    pub tbtesttag: TagTbTestTag,

    pub tbfulltypes: TestTbFullTypes,

    pub tbsingleton: TestTbSingleton,

    pub tbnotindexlist: TestTbNotIndexList,

    pub tbmultiunionindexlist: TestTbMultiUnionIndexList,

    pub tbmultiindexlist: TestTbMultiIndexList,

    pub tbdatafrommisc: TestTbDataFromMisc,

    pub tbmultirowrecord: TestTbMultiRowRecord,

    pub tbtestmulticolumn: TestTbTestMultiColumn,

    pub tbmultirowtitle: TestTbMultiRowTitle,

    pub tbtestnull: TestTbTestNull,

    pub tbdemoprimitive: TestTbDemoPrimitive,

    pub tbteststring: TestTbTestString,

    pub tbdemogroup: TestTbDemoGroup,

    pub tbdemogroup_c: TestTbDemoGroup_C,

    pub tbdemogroup_s: TestTbDemoGroup_S,

    pub tbdemogroup_e: TestTbDemoGroup_E,

    pub tbtestglobal: TestTbTestGlobal,

    pub tbtestberef: TestTbTestBeRef,

    pub tbtestberef2: TestTbTestBeRef2,

    pub tbtestref: TestTbTestRef,

    pub tbtestsize: TestTbTestSize,

    pub tbtestset: TestTbTestSet,

    pub tbdetectcsvencoding: TestTbDetectCsvEncoding,

    pub tbitem2: TestTbItem2,

    pub tbdefinefromexcel: TestTbDefineFromExcel,

    pub tbdefinefromexcelone: TestTbDefineFromExcelOne,

    pub tbtestindex: TestTbTestIndex,

    pub tbtestmap: TestTbTestMap,

    pub tbexcelfromjson: TestTbExcelFromJson,

    pub tbcompositejsontable1: TestTbCompositeJsonTable1,

    pub tbcompositejsontable2: TestTbCompositeJsonTable2,

    pub tbcompositejsontable3: TestTbCompositeJsonTable3,

    pub tbexcelfromjsonmultirow: TestTbExcelFromJsonMultiRow,

    pub tbtestsep: TestTbTestSep,

    pub tbtestscriptableobject: TestTbTestScriptableObject,

    pub tbtestexternaltype: TestTbTestExternalType,

    pub tbdemogroupdefinefromexcel: TestTbDemoGroupDefineFromExcel,

    pub tbdefinefromexcel2: TestTbDefineFromExcel2,

    pub tbtestexcelbean: TestTbTestExcelBean,

    pub tbtestdesc: TestTbTestDesc,
}

impl Tables {
    #[allow(dead_code)]
    pub fn new(loader: JsonLoader) -> std::result::Result<Tables, LoadError> {
        let tables = Tables {
            tbblackboard: AiTbBlackboard::new(&loader("ai_tbblackboard")?)?,
            tbbehaviortree: AiTbBehaviorTree::new(&loader("ai_tbbehaviortree")?)?,
            tbclazz: BlueprintTbClazz::new(&loader("blueprint_tbclazz")?)?,
            tbdrop: BonusTbDrop::new(&loader("bonus_tbdrop")?)?,
            tbglobalconfig: CommonTbGlobalConfig::new(&loader("common_tbglobalconfig")?)?,
            tberrorinfo: ErrorTbErrorInfo::new(&loader("error_tberrorinfo")?)?,
            tbcodeinfo: ErrorTbCodeInfo::new(&loader("error_tbcodeinfo")?)?,
            tbitem: ItemTbItem::new(&loader("item_tbitem")?)?,
            tbitemfunc: ItemTbItemFunc::new(&loader("item_tbitemfunc")?)?,
            tbitemextra: ItemTbItemExtra::new(&loader("item_tbitemextra")?)?,
            tbl10ndemo: L10nTbL10NDemo::new(&loader("l10n_tbl10ndemo")?)?,
            tbpatchdemo: L10nTbPatchDemo::new(&loader("l10n_tbpatchdemo")?)?,
            tbsystemmail: MailTbSystemMail::new(&loader("mail_tbsystemmail")?)?,
            tbglobalmail: MailTbGlobalMail::new(&loader("mail_tbglobalmail")?)?,
            tbrolelevelexpattr: RoleTbRoleLevelExpAttr::new(&loader("role_tbrolelevelexpattr")?)?,
            tbrolelevelbonuscoefficient: RoleTbRoleLevelBonusCoefficient::new(&loader("role_tbrolelevelbonuscoefficient")?)?,
            tbtesttag: TagTbTestTag::new(&loader("tag_tbtesttag")?)?,
            tbfulltypes: TestTbFullTypes::new(&loader("test_tbfulltypes")?)?,
            tbsingleton: TestTbSingleton::new(&loader("test_tbsingleton")?)?,
            tbnotindexlist: TestTbNotIndexList::new(&loader("test_tbnotindexlist")?)?,
            tbmultiunionindexlist: TestTbMultiUnionIndexList::new(&loader("test_tbmultiunionindexlist")?)?,
            tbmultiindexlist: TestTbMultiIndexList::new(&loader("test_tbmultiindexlist")?)?,
            tbdatafrommisc: TestTbDataFromMisc::new(&loader("test_tbdatafrommisc")?)?,
            tbmultirowrecord: TestTbMultiRowRecord::new(&loader("test_tbmultirowrecord")?)?,
            tbtestmulticolumn: TestTbTestMultiColumn::new(&loader("test_tbtestmulticolumn")?)?,
            tbmultirowtitle: TestTbMultiRowTitle::new(&loader("test_tbmultirowtitle")?)?,
            tbtestnull: TestTbTestNull::new(&loader("test_tbtestnull")?)?,
            tbdemoprimitive: TestTbDemoPrimitive::new(&loader("test_tbdemoprimitive")?)?,
            tbteststring: TestTbTestString::new(&loader("test_tbteststring")?)?,
            tbdemogroup: TestTbDemoGroup::new(&loader("test_tbdemogroup")?)?,
            tbdemogroup_c: TestTbDemoGroup_C::new(&loader("test_tbdemogroup_c")?)?,
            tbdemogroup_s: TestTbDemoGroup_S::new(&loader("test_tbdemogroup_s")?)?,
            tbdemogroup_e: TestTbDemoGroup_E::new(&loader("test_tbdemogroup_e")?)?,
            tbtestglobal: TestTbTestGlobal::new(&loader("test_tbtestglobal")?)?,
            tbtestberef: TestTbTestBeRef::new(&loader("test_tbtestberef")?)?,
            tbtestberef2: TestTbTestBeRef2::new(&loader("test_tbtestberef2")?)?,
            tbtestref: TestTbTestRef::new(&loader("test_tbtestref")?)?,
            tbtestsize: TestTbTestSize::new(&loader("test_tbtestsize")?)?,
            tbtestset: TestTbTestSet::new(&loader("test_tbtestset")?)?,
            tbdetectcsvencoding: TestTbDetectCsvEncoding::new(&loader("test_tbdetectcsvencoding")?)?,
            tbitem2: TestTbItem2::new(&loader("test_tbitem2")?)?,
            tbdefinefromexcel: TestTbDefineFromExcel::new(&loader("test_tbdefinefromexcel")?)?,
            tbdefinefromexcelone: TestTbDefineFromExcelOne::new(&loader("test_tbdefinefromexcelone")?)?,
            tbtestindex: TestTbTestIndex::new(&loader("test_tbtestindex")?)?,
            tbtestmap: TestTbTestMap::new(&loader("test_tbtestmap")?)?,
            tbexcelfromjson: TestTbExcelFromJson::new(&loader("test_tbexcelfromjson")?)?,
            tbcompositejsontable1: TestTbCompositeJsonTable1::new(&loader("test_tbcompositejsontable1")?)?,
            tbcompositejsontable2: TestTbCompositeJsonTable2::new(&loader("test_tbcompositejsontable2")?)?,
            tbcompositejsontable3: TestTbCompositeJsonTable3::new(&loader("test_tbcompositejsontable3")?)?,
            tbexcelfromjsonmultirow: TestTbExcelFromJsonMultiRow::new(&loader("test_tbexcelfromjsonmultirow")?)?,
            tbtestsep: TestTbTestSep::new(&loader("test_tbtestsep")?)?,
            tbtestscriptableobject: TestTbTestScriptableObject::new(&loader("test_tbtestscriptableobject")?)?,
            tbtestexternaltype: TestTbTestExternalType::new(&loader("test_tbtestexternaltype")?)?,
            tbdemogroupdefinefromexcel: TestTbDemoGroupDefineFromExcel::new(&loader("test_tbdemogroupdefinefromexcel")?)?,
            tbdefinefromexcel2: TestTbDefineFromExcel2::new(&loader("test_tbdefinefromexcel2")?)?,
            tbtestexcelbean: TestTbTestExcelBean::new(&loader("test_tbtestexcelbean")?)?,
            tbtestdesc: TestTbTestDesc::new(&loader("test_tbtestdesc")?)?,
        };
        return Ok(tables);
    }
}
